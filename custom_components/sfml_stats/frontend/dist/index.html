<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFML Hybrid-AI Dashboard by Zara</title>

    <!-- ECharts for Charts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

    <!-- Vue 3 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js"></script>

    <style>
        /* ============================================================
           CSS Variables - Modern Dark Neon Theme (Redesigned)
           ============================================================ */
        :root {
            /* Tiefere, modernere Hintergrundfarben */
            --bg-dark: #0d1117;
            --bg-medium: #161b22;
            --bg-light: #21262d;
            --bg-card: #1c2128;
            --bg-card-hover: #262c36;

            /* Lebendige Neon-Akzente */
            --neon-yellow: #ffd60a;
            --neon-orange: #ff9500;
            --neon-gold: #ffb627;
            --neon-cyan: #00d4ff;
            --neon-green: #39ff14;
            --neon-pink: #ff2e97;
            --neon-purple: #a855f7;
            --neon-blue: #6366f1;
            --neon-battery: #10b981;

            /* Verbesserte Textfarben */
            --text-white: #f0f6fc;
            --text-light: #c9d1d9;
            --text-muted: #8b949e;
            --text-dark: #6e7681;

            /* Moderne Gradienten */
            --gradient-card: linear-gradient(145deg, var(--bg-card), var(--bg-medium));
            --gradient-header: linear-gradient(135deg, var(--neon-cyan) 0%, var(--neon-purple) 100%);
            --gradient-solar: linear-gradient(135deg, var(--neon-gold), var(--neon-orange));
            --gradient-glow: radial-gradient(ellipse at center, var(--neon-cyan), transparent 70%);

            /* Glassmorphism */
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);

            /* Rahmen */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-accent: rgba(0, 212, 255, 0.25);
            --border-glow: rgba(0, 212, 255, 0.5);

            /* Abstände */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;

            /* Rundungen */
            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.25rem;

            /* Animationen */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.25s ease;
            --transition-slow: 0.4s ease;
        }

        /* ============================================================
           Light Theme Override
           ============================================================ */
        :root.light-theme {
            --bg-dark: #f0f4f8;
            --bg-medium: #e2e8f0;
            --bg-light: #ffffff;
            --bg-card: #ffffff;
            --neon-yellow: #d97706;
            --neon-orange: #ea580c;
            --neon-cyan: #0891b2;
            --neon-green: #059669;
            --neon-pink: #db2777;
            --neon-purple: #7c3aed;
            --neon-blue: #2563eb;
            --neon-battery: #16a34a;
            --text-white: #1e293b;
            --text-light: #334155;
            --text-muted: #64748b;
            --text-dark: #94a3b8;
            --gradient-card: linear-gradient(145deg, #ffffff, #f1f5f9);
            --border-subtle: rgba(0, 0, 0, 0.1);
            --border-accent: rgba(8, 145, 178, 0.3);
        }

        /* Theme Toggle Button */
        .theme-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-sm);
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow-x: hidden; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-light);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Moderne Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-medium);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--neon-cyan), var(--neon-purple));
            border-radius: 5px;
            border: 2px solid var(--bg-medium);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--neon-purple), var(--neon-cyan));
        }

        /* Selection Styling */
        ::selection {
            background: rgba(0, 212, 255, 0.3);
            color: var(--text-white);
        }

        #app {
            min-height: 100vh;
            position: relative;
        }

        /* Hintergrundbild-Layer (fixiert, skaliert automatisch) */
        #app::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;

            /* Hintergrundbild - über assets endpoint */
            background-image: url('/api/sfml_stats/assets/background.png');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-attachment: fixed;

            /* Fallback-Farbe */
            background-color: var(--bg-dark);
        }

        /* Overlay für bessere Lesbarkeit der UI-Elemente */
        #app::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            background:
                /* Stärkerer Gradient oben für Header */
                linear-gradient(180deg,
                    rgba(13, 17, 23, 0.92) 0%,
                    rgba(13, 17, 23, 0.75) 8%,
                    rgba(13, 17, 23, 0.5) 25%,
                    transparent 50%
                ),
                /* Gradient unten */
                linear-gradient(0deg,
                    rgba(13, 17, 23, 0.85) 0%,
                    rgba(13, 17, 23, 0.4) 20%,
                    transparent 40%
                ),
                /* Allgemeines semi-transparentes Overlay */
                rgba(13, 17, 23, 0.45),
                /* Dezente farbige Akzente passend zum Bild */
                radial-gradient(ellipse at 20% 80%, rgba(168, 85, 247, 0.12), transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 212, 255, 0.08), transparent 50%);
        }

        /* Header - Modernisiert mit Glassmorphism */
        .header {
            padding: var(--spacing-md) var(--spacing-xl);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.95), rgba(22, 27, 34, 0.9));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--gradient-header);
            opacity: 0.8;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 800;
            background: var(--gradient-header);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
            letter-spacing: -0.02em;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--neon-green);
            animation: pulse-glow 2s ease-in-out infinite;
            display: inline-block;
            margin-right: 8px;
            box-shadow: 0 0 10px var(--neon-green), 0 0 20px rgba(57, 255, 20, 0.3);
        }

        @keyframes pulse-glow {
            0%, 100% {
                opacity: 1;
                box-shadow: 0 0 10px var(--neon-green), 0 0 20px rgba(57, 255, 20, 0.3);
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                box-shadow: 0 0 15px var(--neon-green), 0 0 30px rgba(57, 255, 20, 0.5);
                transform: scale(1.1);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            50% { opacity: 0.8; box-shadow: 0 0 0 6px rgba(0, 255, 136, 0); }
        }

        /* Main */
        .main-content {
            padding: var(--spacing-lg);
            max-width: 1800px;
            margin: 0 auto;
        }

        /* ============================================================
           NEW: Energy Flow Diagram - Pure SVG Approach
           ============================================================ */
        .energy-flow-container {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.85));
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--glass-shadow), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .energy-flow-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: radial-gradient(ellipse at top center, rgba(0, 212, 255, 0.05), transparent 50%);
            pointer-events: none;
        }

        .energy-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .energy-flow-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-white);
        }

        .energy-flow-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .energy-flow-svg {
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            display: block;
        }

        /* Glow effects for nodes */
        .node-glow-solar { filter: drop-shadow(0 0 15px rgba(251, 191, 36, 0.6)); }
        .node-glow-battery { filter: drop-shadow(0 0 15px rgba(34, 197, 94, 0.6)); }
        .node-glow-home { filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.6)); }
        .node-glow-grid { filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.6)); }

        /* Pulsing animations for active nodes */
        @keyframes pulse-solar {
            0%, 100% { filter: drop-shadow(0 0 15px rgba(251, 191, 36, 0.6)); }
            50% { filter: drop-shadow(0 0 25px rgba(251, 191, 36, 0.9)); }
        }
        @keyframes pulse-battery {
            0%, 100% { filter: drop-shadow(0 0 15px rgba(34, 197, 94, 0.6)); }
            50% { filter: drop-shadow(0 0 25px rgba(34, 197, 94, 0.9)); }
        }
        @keyframes pulse-home {
            0%, 100% { filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.6)); }
            50% { filter: drop-shadow(0 0 25px rgba(0, 255, 255, 0.9)); }
        }
        @keyframes pulse-grid {
            0%, 100% { filter: drop-shadow(0 0 15px rgba(139, 92, 246, 0.6)); }
            50% { filter: drop-shadow(0 0 25px rgba(139, 92, 246, 0.9)); }
        }
        .node-glow-solar.active { animation: pulse-solar 2s ease-in-out infinite; }
        .node-glow-battery.active { animation: pulse-battery 2s ease-in-out infinite; }
        .node-glow-home.active { animation: pulse-home 2s ease-in-out infinite; }
        .node-glow-grid.active { animation: pulse-grid 2s ease-in-out infinite; }

        /* ============================================================
           Panel Grid - Individual PV Panels Display
           ============================================================ */
        .panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            padding-top: var(--spacing-md);
            border-top: 1px solid var(--border-subtle);
        }

        .panel-card {
            background: linear-gradient(145deg, rgba(255, 214, 10, 0.08), rgba(255, 149, 0, 0.04));
            border: 1px solid rgba(255, 214, 10, 0.25);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            text-align: center;
            transition: all var(--transition-normal);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .panel-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at top, rgba(255, 214, 10, 0.1), transparent 70%);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .panel-card:hover {
            border-color: var(--neon-gold);
            box-shadow: 0 8px 32px rgba(255, 214, 10, 0.2), 0 0 20px rgba(255, 214, 10, 0.15);
            transform: translateY(-4px) scale(1.02);
        }

        .panel-card:hover::before {
            opacity: 1;
        }

        .panel-card-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: var(--spacing-xs);
        }

        .panel-card-icon {
            width: 22px;
            height: 22px;
        }

        .panel-card-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--neon-yellow);
        }

        .panel-card-power {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text-white);
            text-shadow: 0 0 10px rgba(255, 221, 0, 0.3);
        }

        .panel-card-unit {
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        /* ============================================================
           Energy Balance Widget - Stromrechnung & Autarkie
           ============================================================ */
        .energy-balance-container {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.85));
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--glass-shadow);
        }

        .energy-balance-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(0, 212, 255, 0.03), transparent 30%);
            animation: rotate-glow 20s linear infinite;
            pointer-events: none;
        }

        @keyframes rotate-glow {
            100% { transform: rotate(360deg); }
        }

        .energy-balance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .tariff-link-btn {
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            border: 1px solid rgba(0, 212, 255, 0.4);
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(168, 85, 247, 0.05));
            color: var(--neon-cyan);
            font-size: 0.8rem;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }
        .tariff-link-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent, rgba(0, 212, 255, 0.2), transparent);
            transform: translateX(-100%);
            transition: transform 0.5s ease;
        }
        .tariff-link-btn:hover {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(168, 85, 247, 0.1));
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3), inset 0 0 20px rgba(0, 212, 255, 0.05);
            transform: translateY(-2px);
            border-color: var(--neon-cyan);
        }
        .tariff-link-btn:hover::before {
            transform: translateX(100%);
        }

        .energy-balance-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-white);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .energy-balance-period {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .energy-balance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .energy-balance-item {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0.15));
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            text-align: center;
            border: 1px solid var(--glass-border);
            transition: all var(--transition-normal);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            position: relative;
            z-index: 1;
        }

        .energy-balance-item:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .energy-balance-item.total {
            border-color: var(--neon-yellow);
            background: linear-gradient(135deg, rgba(255, 221, 0, 0.1) 0%, rgba(255, 170, 0, 0.05) 100%);
        }

        .energy-balance-item.solar {
            border-color: var(--neon-yellow);
            background: linear-gradient(135deg, rgba(255, 221, 0, 0.1) 0%, rgba(255, 170, 0, 0.05) 100%);
        }

        .energy-balance-item.battery {
            border-color: var(--neon-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
        }

        .energy-balance-item.grid {
            border-color: var(--neon-purple);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
        }

        .energy-balance-item.autarkie {
            border-color: var(--neon-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
        }

        .energy-balance-item.cost {
            border-color: var(--neon-purple);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
        }

        .energy-balance-item.savings {
            border-color: var(--neon-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
        }

        .energy-balance-item.projection {
            border-color: var(--neon-cyan);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.05) 100%);
        }

        .energy-balance-icon {
            font-size: 1.8rem;
            margin-bottom: 4px;
        }

        .energy-balance-value {
            font-size: 1.8rem;
            font-weight: 700;
            line-height: 1.2;
        }

        .energy-balance-value.green { color: var(--neon-green); }
        .energy-balance-value.cyan { color: var(--neon-cyan); }
        .energy-balance-value.yellow { color: var(--neon-yellow); }
        .energy-balance-value.purple { color: var(--neon-purple); }
        .energy-balance-value.pink { color: var(--neon-pink); }

        .energy-balance-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .energy-balance-sub {
            font-size: 0.65rem;
            color: var(--text-dark);
            margin-top: 2px;
        }

        /* Autarkie Donut */
        .autarkie-donut-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm);
        }

        .autarkie-donut {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .autarkie-donut svg {
            transform: rotate(-90deg);
        }

        .autarkie-donut-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 12;
        }

        .autarkie-donut-progress {
            fill: none;
            stroke: url(#autarkie-gradient);
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 0 8px var(--neon-green));
        }

        .autarkie-donut-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .autarkie-donut-value {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--neon-green);
            line-height: 1;
        }

        .autarkie-donut-label {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* Breakdown Bar */
        .energy-breakdown {
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .energy-breakdown-title {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: var(--spacing-sm);
        }

        .energy-breakdown-bar {
            height: 24px;
            border-radius: 12px;
            display: flex;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
        }

        .energy-breakdown-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: #0a0a1a;
            transition: width 0.5s ease-out;
            min-width: 0;
        }

        .energy-breakdown-segment.solar { background: var(--neon-yellow); }
        .energy-breakdown-segment.battery { background: var(--neon-green); }
        .energy-breakdown-segment.grid { background: var(--neon-purple); }

        .energy-breakdown-legend {
            display: flex;
            justify-content: center;
            gap: var(--spacing-lg);
            margin-top: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .energy-breakdown-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .energy-breakdown-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .energy-breakdown-legend-dot.solar { background: var(--neon-yellow); }
        .energy-breakdown-legend-dot.battery { background: var(--neon-green); }
        .energy-breakdown-legend-dot.grid { background: var(--neon-purple); }

        /* ============================================================
           Power Sources Card - Clickable Preview
           ============================================================ */
        .power-sources-card {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.85));
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--glass-shadow);
            position: relative;
            overflow: hidden;
        }

        .power-sources-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 182, 39, 0.08), transparent 70%);
            pointer-events: none;
        }

        .power-sources-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .power-sources-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-white);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .power-sources-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .power-sources-chart-container {
            height: 280px;
            width: 100%;
        }

        .power-sources-legend {
            display: flex;
            justify-content: center;
            gap: var(--spacing-lg);
            margin-top: var(--spacing-md);
            flex-wrap: wrap;
        }

        .power-sources-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .power-sources-legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .power-sources-legend-dot.solar { background: #FFB74D; }
        .power-sources-legend-dot.battery { background: #4DD0E1; }
        .power-sources-legend-dot.grid { background: #90CAF9; }
        .power-sources-legend-dot.consumption { background: #1a1a1a; border: 2px solid #ffffff; }

        /* ============================================================
           Forecast Overview - 3-Day Forecast Section
           ============================================================ */
        .forecast-overview-container {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.85));
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--glass-shadow);
            position: relative;
        }

        .forecast-overview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(57, 255, 20, 0.06), transparent 70%);
            pointer-events: none;
        }

        .forecast-overview-header {
            margin-bottom: var(--spacing-md);
        }

        .forecast-overview-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-white);
        }

        .forecast-overview-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .forecast-days-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-md);
        }

        @media (max-width: 900px) {
            .forecast-days-grid {
                grid-template-columns: 1fr;
            }
        }

        .forecast-day-card {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.2));
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid var(--glass-border);
            transition: all var(--transition-normal);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .forecast-day-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            opacity: 0.8;
        }

        .forecast-day-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .forecast-day-card.today {
            border-color: rgba(57, 255, 20, 0.4);
        }
        .forecast-day-card.today::after {
            background: linear-gradient(90deg, var(--neon-green), transparent);
        }
        .forecast-day-card.today:hover {
            box-shadow: 0 8px 24px rgba(57, 255, 20, 0.15);
        }

        .forecast-day-card.tomorrow {
            border-color: rgba(0, 212, 255, 0.4);
        }
        .forecast-day-card.tomorrow::after {
            background: linear-gradient(90deg, var(--neon-cyan), transparent);
        }
        .forecast-day-card.tomorrow:hover {
            box-shadow: 0 8px 24px rgba(0, 212, 255, 0.15);
        }

        .forecast-day-card.day-after-tomorrow {
            border-color: rgba(168, 85, 247, 0.4);
        }
        .forecast-day-card.day-after-tomorrow::after {
            background: linear-gradient(90deg, var(--neon-purple), transparent);
        }
        .forecast-day-card.day-after-tomorrow:hover {
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.15);
        }

        .forecast-day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .forecast-day-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-white);
        }

        .forecast-day-card.today .forecast-day-label { color: var(--neon-green); }
        .forecast-day-card.tomorrow .forecast-day-label { color: var(--neon-cyan); }
        .forecast-day-card.day-after-tomorrow .forecast-day-label { color: var(--neon-purple); }

        .forecast-day-total {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-white);
        }

        .forecast-day-details {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .forecast-detail {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .forecast-hourly-bars {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 80px;
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--border-subtle);
        }

        .forecast-bar-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            cursor: pointer;
        }

        .forecast-bar {
            width: 100%;
            min-height: 2px;
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
            margin-top: auto;
        }

        .forecast-bar.today-bar { background: linear-gradient(to top, var(--neon-green), #00ff8855); }
        .forecast-bar.tomorrow-bar { background: linear-gradient(to top, var(--neon-cyan), #00ffff55); }
        .forecast-bar.dayafter-bar { background: linear-gradient(to top, var(--neon-purple), #8b5cf655); }

        .forecast-bar-label {
            font-size: 0.6rem;
            color: var(--text-dark);
            margin-top: 2px;
        }

        .forecast-no-data {
            width: 100%;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: var(--spacing-md);
        }

        /* ============================================================
           Statistics Cards
           ============================================================ */
        .stats-container {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.85));
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            margin-bottom: var(--spacing-lg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--glass-shadow);
        }
        .stats-container-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }
        .stats-container-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-white);
        }
        .stats-container-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
        }

        .stat-card {
            background: linear-gradient(145deg, var(--bg-card), rgba(22, 27, 34, 0.8));
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--spacing-lg);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--glass-shadow);
            transition: all var(--transition-normal);
        }

        .stat-card:hover {
            transform: translateY(-4px);
            border-color: var(--border-accent);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 212, 255, 0.1);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at top right, rgba(255, 255, 255, 0.03), transparent 60%);
            pointer-events: none;
        }

        .stat-card.peak::before { background: linear-gradient(90deg, var(--neon-yellow), var(--neon-orange)); }
        .stat-card.production::before { background: var(--neon-green); }
        .stat-card.grid::before { background: var(--neon-purple); }
        .stat-card.battery::before { background: var(--neon-battery); }
        .stat-card.astro::before { background: linear-gradient(90deg, #fbbf24, #f97316); }

        .stat-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--spacing-sm);
        }

        .stat-card-icon {
            font-size: 1.5rem;
        }

        .stat-card-badge {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
        }

        .stat-card-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .stat-card.peak .stat-card-value { color: var(--neon-yellow); }
        .stat-card.production .stat-card-value { color: var(--neon-green); }
        .stat-card.grid .stat-card-value { color: var(--neon-purple); }
        .stat-card.battery .stat-card-value { color: var(--neon-battery); }
        .stat-card.astro .stat-card-value { color: #fbbf24; }

        .stat-card-label {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .stat-card-sub {
            font-size: 0.7rem;
            color: var(--text-dark);
            margin-top: 4px;
        }

        /* ============================================================
           Top Row: 2 Widget Groups
           ============================================================ */
        .top-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        @media (max-width: 900px) {
            .top-row {
                grid-template-columns: 1fr;
            }
            .widget-group-container {
                flex-direction: column;
            }
        }

        /* Widget Groups */
        .widget-group {
            display: contents;
        }

        .widget-group-container {
            display: flex;
            gap: var(--spacing-md);
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-sm);
        }

        .widget-group-container .weather-widget {
            flex: 1;
            margin: 0;
        }

        .widget-group-label {
            position: absolute;
            top: -10px;
            left: 12px;
            background: var(--bg-dark);
            padding: 0 8px;
            font-size: 0.65rem;
            color: var(--text-dark);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .widget-group-container {
            position: relative;
        }

        /* Info Widgets (Forecast, Yield, Price) */
        .info-widget {
            background: var(--gradient-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            display: flex;
            flex-direction: column;
        }

        .info-widget-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .info-widget-icon {
            font-size: 1.3rem;
        }

        .info-widget-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
        }

        .info-widget-value {
            font-size: 2.2rem;
            font-weight: 700;
            line-height: 1;
        }

        .info-widget-value.green { color: var(--neon-green); }
        .info-widget-value.yellow { color: var(--neon-yellow); }
        .info-widget-value.pink { color: var(--neon-pink); }
        .info-widget-value.purple { color: var(--neon-purple); }

        .info-widget-unit {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: var(--spacing-xs);
        }

        /* Forecast Compact */
        .forecast-compact {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            flex: 1;
            justify-content: center;
        }

        .forecast-compact-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forecast-compact-label {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .forecast-compact-value {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .forecast-compact-value.yellow { color: var(--neon-yellow); }
        .forecast-compact-value.purple { color: var(--neon-purple); }
        .forecast-compact-value.muted { color: var(--text-dark); font-weight: 500; }

        /* ============================================================
           Original Sections (Weather, Live Values, Forecast, etc.)
           ============================================================ */
        .top-bar {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        @media (max-width: 1000px) {
            .top-bar { grid-template-columns: 1fr; }
        }

        /* Weather Widget */
        .weather-widget {
            background: var(--gradient-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .weather-main {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .weather-icon { font-size: 2.5rem; }
        .weather-temp {
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--neon-cyan);
        }

        .weather-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            font-size: 0.85rem;
        }

        .weather-detail {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-muted);
        }

        .weather-detail span:last-child { color: var(--text-light); font-weight: 500; }

        /* Live Values */
        .live-values {
            background: var(--gradient-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-md);
        }

        .live-value-item {
            text-align: center;
            padding: var(--spacing-sm);
        }

        .live-value-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; }
        .live-value-number { font-size: 1.4rem; font-weight: 700; }
        .live-value-number.power { color: var(--neon-yellow); }
        .live-value-number.yield { color: var(--neon-green); }
        .live-value-number.price { color: var(--neon-pink); }
        .live-value-number.forecast { color: var(--neon-purple); }
        .live-value-number.battery { color: var(--neon-battery); }

        /* Forecast Section */
        .forecast-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        @media (max-width: 900px) {
            .forecast-section { grid-template-columns: 1fr; }
        }

        .forecast-card {
            background: var(--gradient-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .forecast-title { font-size: 0.95rem; font-weight: 600; }
        .forecast-total { font-size: 1.4rem; font-weight: 700; color: var(--neon-yellow); }

        .forecast-hours {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .forecast-hour {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 42px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-sm);
        }

        .forecast-hour-time { font-size: 0.65rem; color: var(--text-muted); }
        .forecast-hour-value { font-size: 0.75rem; font-weight: 600; color: var(--neon-yellow); }

        .forecast-hour-bar {
            width: 16px;
            background: linear-gradient(to top, var(--neon-yellow), var(--neon-orange));
            border-radius: 2px;
            margin-top: 4px;
            min-height: 3px;
        }

        /* KPI Grid */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .kpi-card {
            background: var(--gradient-card);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            position: relative;
            overflow: hidden;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
        }

        .kpi-card.solar::before { background: linear-gradient(90deg, #fbbf24, #d97706); }
        .kpi-card.accuracy::before { background: var(--neon-cyan); }
        .kpi-card.price::before { background: var(--neon-green); }
        .kpi-card.forecast::before { background: var(--neon-purple); }

        .kpi-value { font-size: 1.5rem; font-weight: 700; }
        .kpi-card.solar .kpi-value { color: var(--neon-yellow); }
        .kpi-card.accuracy .kpi-value { color: var(--neon-cyan); }
        .kpi-card.price .kpi-value { color: var(--neon-green); }
        .kpi-card.forecast .kpi-value { color: var(--neon-purple); }

        .kpi-label { font-size: 0.75rem; color: var(--text-muted); margin-top: 4px; }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        @media (max-width: 1100px) {
            .charts-grid { grid-template-columns: 1fr; }
        }

        .chart-card {
            background: var(--gradient-card);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .chart-card.full-width { grid-column: 1 / -1; }
        .chart-title { font-size: 0.95rem; font-weight: 600; margin-bottom: var(--spacing-md); }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }
        .chart-header .chart-title { margin-bottom: 0; }
        .chart-stats {
            display: flex;
            gap: var(--spacing-md);
        }
        .chart-stat {
            font-size: 0.8rem;
            font-weight: 600;
        }
        .chart-stat.max { color: #ef4444; }
        .chart-stat.min { color: #22c55e; }
        .chart-stat small { color: var(--text-muted); font-weight: 400; }
        .chart-container { height: 260px; }
        .chart-container.tall { height: 320px; }

        /* Footer */
        .footer {
            padding: var(--spacing-md) var(--spacing-lg);
            border-top: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-dark);
        }

        .footer-tags { display: flex; gap: 6px; }

        .footer-tag {
            padding: 3px 8px;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 4px;
            color: var(--neon-purple);
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--bg-light); border-radius: 3px; }

        /* ============================================================
           MODAL SYSTEM - Solar Analytics
           ============================================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 26, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-lg);
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-container {
            background: var(--gradient-card);
            border: 2px solid var(--neon-yellow);
            border-radius: var(--radius-lg);
            max-width: 1400px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(255, 221, 0, 0.3);
            animation: slideUp 0.4s ease-out;
            position: relative;
        }

        /* Spezifische Modal-Farben basierend auf Nodes */
        .modal-container.battery-modal {
            border-color: #22c55e;
            box-shadow: 0 0 40px rgba(34, 197, 94, 0.3);
        }

        .modal-container.house-modal {
            border-color: #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
        }

        .modal-container.grid-modal {
            border-color: #8b5cf6;
            box-shadow: 0 0 40px rgba(139, 92, 246, 0.3);
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 10;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-orange));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-subtle);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2rem;
            color: var(--text-light);
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            transform: rotate(90deg);
        }

        .modal-export-btn {
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-orange));
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            color: var(--bg-dark);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.3);
        }

        .modal-export-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(255, 221, 0, 0.5);
        }

        .modal-export-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .modal-body {
            padding: var(--spacing-lg);
        }

        .modal-tabs {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            border-bottom: 2px solid var(--border-subtle);
        }

        .modal-tab {
            padding: var(--spacing-sm) var(--spacing-lg);
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .modal-tab:hover {
            color: var(--text-light);
            background: rgba(255, 255, 255, 0.05);
        }

        .modal-tab.active {
            color: var(--neon-yellow);
            border-bottom-color: var(--neon-yellow);
        }

        .modal-chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: var(--spacing-lg);
        }

        .modal-chart-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
        }

        .modal-chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-white);
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .modal-stat-card {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            text-align: center;
            transition: transform 0.2s, border-color 0.2s;
        }

        .modal-stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--neon-yellow);
        }

        /* Spezifische Stat-Card Hover-Farben */
        .battery-modal .modal-stat-card:hover {
            border-color: #22c55e;
        }

        .house-modal .modal-stat-card:hover {
            border-color: #00ffff;
        }

        .grid-modal .modal-stat-card:hover {
            border-color: #8b5cf6;
        }

        .weather-modal {
            border-color: #f59e0b;
            box-shadow: 0 0 40px rgba(245, 158, 11, 0.3);
        }

        .weather-modal .modal-stat-card:hover {
            border-color: #f59e0b;
        }

        /* Clothing Modal */
        .clothing-modal {
            border-color: #ec4899;
            box-shadow: 0 0 40px rgba(236, 72, 153, 0.3);
        }
        .clothing-modal .modal-stat-card:hover {
            border-color: #ec4899;
        }
        .clothing-text-container {
            background: linear-gradient(145deg, rgba(236, 72, 153, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            margin: var(--spacing-lg) 0;
        }
        .clothing-recommendation-text {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-light);
            margin: 0;
        }
        .clothing-items-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
            margin: var(--spacing-lg) 0;
        }
        @media (max-width: 768px) {
            .clothing-items-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .clothing-item {
            background: var(--gradient-card);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: var(--spacing-lg);
            text-align: center;
            transition: all 0.3s ease;
        }
        .clothing-item:hover {
            border-color: #ec4899;
            transform: translateY(-2px);
        }
        .clothing-item-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-sm);
        }
        .clothing-item-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
        }
        .clothing-item-label {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        .clothing-accessories {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
        }
        .clothing-accessories-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: var(--spacing-sm);
        }
        .clothing-accessories-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }
        .clothing-accessory {
            background: linear-gradient(145deg, rgba(236, 72, 153, 0.2), rgba(139, 92, 246, 0.2));
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.95rem;
            color: var(--text-light);
        }
        /* Clothing Widget Button */
        .clothing-widget-btn {
            background: linear-gradient(145deg, rgba(236, 72, 153, 0.2), rgba(139, 92, 246, 0.2));
            border: 1px solid rgba(236, 72, 153, 0.4);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            color: var(--text-light);
            font-size: 0.9rem;
        }
        .clothing-widget-btn:hover {
            border-color: #ec4899;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.4);
            transform: translateY(-1px);
        }
        .clothing-widget-btn .btn-icon {
            font-size: 1.2rem;
        }

        .modal-stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--neon-yellow);
            margin-bottom: 4px;
        }

        .modal-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Clickable Node Styling */
        .node-clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node-clickable:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 0 25px currentColor) !important;
        }

        /* ============================================================
           Toast Notification System
           ============================================================ */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 20px;
            border-radius: var(--radius-md);
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            color: var(--text-light);
            font-size: 0.9rem;
            pointer-events: auto;
            animation: toastSlideIn 0.3s ease-out;
            max-width: 400px;
        }

        .toast.toast-success {
            border-color: var(--neon-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), var(--bg-card));
        }

        .toast.toast-error {
            border-color: var(--neon-pink);
            background: linear-gradient(135deg, rgba(255, 0, 128, 0.1), var(--bg-card));
        }

        .toast.toast-warning {
            border-color: var(--neon-orange);
            background: linear-gradient(135deg, rgba(255, 140, 0, 0.1), var(--bg-card));
        }

        .toast.toast-info {
            border-color: var(--neon-cyan);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), var(--bg-card));
        }

        .toast-icon {
            font-size: 1.3rem;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .toast-message {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            font-size: 1.1rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .toast-close:hover {
            opacity: 1;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease-in forwards;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Loading Spinner */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 26, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: inherit;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--neon-cyan);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .card-loading {
            position: relative;
            min-height: 100px;
        }
    </style>
</head>
<body>
    <!-- Toast Notification Container -->
    <div id="toast-container" class="toast-container"></div>

    <div id="app">
        <header class="header">
            <h1>SFML Hybrid-AI Dashboard by Zara</h1>
            <div style="display: flex; align-items: center; gap: 12px;">
                <button @click="toggleTheme" class="theme-toggle" :title="isDarkTheme ? 'Zu Hell wechseln' : 'Zu Dunkel wechseln'">
                    {{ isDarkTheme ? '☀️' : '🌙' }}
                </button>
                <span><span class="status-dot"></span>Live</span>
                <span style="color: var(--text-muted)">{{ lastUpdate }}</span>
            </div>
        </header>

        <main class="main-content">
            <!-- Top Row: Weather Groups, Forecast, Yield, Price -->
            <section class="top-row">
                <!-- Gruppe 1: IST + KI-Korrigiert -->
                <div class="widget-group-container">
                    <span class="widget-group-label">🛰️ Sensoren-Array</span>
                    <!-- Weather Widget: IST (Sensoren) - CLICKABLE -->
                    <div class="weather-widget clickable" @click="openWeatherModal" style="border-color: #10b981; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">{{ weatherIcon }}</div>
                            <div>
                                <div class="weather-temp">{{ weather.temperature?.toFixed(1) || '—' }}°C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">IST (Sensoren)</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>☀️</span><span>{{ weather.radiation?.toFixed(0) || '0' }} W/m²</span></div>
                            <div class="weather-detail"><span>💧</span><span>{{ weather.humidity?.toFixed(0) || '—' }}%</span></div>
                            <div class="weather-detail"><span>🌬️</span><span>{{ weather.wind?.toFixed(1) || '—' }} m/s</span></div>
                            <div class="weather-detail"><span>☁️</span><span>{{ weather.clouds?.toFixed(0) || '—' }}%</span></div>
                        </div>
                    </div>

                    <!-- Weather Widget: KI-Korrigiert - CLICKABLE -->
                    <div class="weather-widget clickable" @click="openWeatherModal" style="border-color: #8b5cf6; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">🤖</div>
                            <div>
                                <div class="weather-temp" style="color: #8b5cf6;">{{ weatherCorrected.temperature?.toFixed(1) || '—' }}°C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">KI-Korrigiert</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>☀️</span><span>{{ weatherCorrected.radiation?.toFixed(0) || '0' }} W/m²</span></div>
                            <div class="weather-detail"><span>💧</span><span>{{ weatherCorrected.humidity?.toFixed(0) || '—' }}%</span></div>
                            <div class="weather-detail"><span>🌬️</span><span>{{ weatherCorrected.wind?.toFixed(1) || '—' }} m/s</span></div>
                            <div class="weather-detail"><span>☁️</span><span>{{ weatherCorrected.clouds?.toFixed(0) || '—' }}%</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 2: HA Wetter + Sonne -->
                <div class="widget-group-container">
                    <span class="widget-group-label">🖖 Außenmission</span>
                    <!-- Weather Widget: HA Integration -->
                    <div class="weather-widget" style="border-color: #3b82f6;">
                        <div class="weather-main">
                            <div class="weather-icon">{{ weatherHAIcon }}</div>
                            <div>
                                <div class="weather-temp" style="color: #3b82f6;">{{ weatherHA.temperature?.toFixed(1) || '—' }}°C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">HA Wetter</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>📍</span><span>{{ weatherHA.state || '—' }}</span></div>
                            <div class="weather-detail"><span>💧</span><span>{{ weatherHA.humidity?.toFixed(0) || '—' }}%</span></div>
                            <div class="weather-detail"><span>🌬️</span><span>{{ weatherHA.wind_speed?.toFixed(1) || '—' }} m/s</span></div>
                            <div class="weather-detail"><span>☁️</span><span>{{ weatherHA.cloud_coverage?.toFixed(0) || '—' }}%</span></div>
                        </div>
                    </div>

                    <!-- Clothing Recommendation Widget -->
                    <div class="weather-widget clickable" @click="openClothingModal" style="border-color: #ec4899; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">🖖</div>
                            <div>
                                <div class="weather-temp" style="color: #ec4899;">Außenteam</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Ausrüstung</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>🌡️</span><span>{{ weather.temperature?.toFixed(0) || '—' }}°C</span></div>
                            <div class="weather-detail"><span>💨</span><span>{{ weather.wind?.toFixed(1) || '—' }} m/s</span></div>
                            <div class="weather-detail"><span>💧</span><span>{{ weather.humidity?.toFixed(0) || '—' }}%</span></div>
                            <div class="weather-detail"><span>☁️</span><span>{{ weather.clouds?.toFixed(0) || '—' }}%</span></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Energy Flow Diagram -->
            <section class="energy-flow-container">
                <div class="energy-flow-header">
                    <div>
                        <div class="energy-flow-title">⚡ Energie-Matrix</div>
                        <div class="energy-flow-subtitle">Echtzeit-Leistungsverteilung • Warp-Kern Status</div>
                    </div>
                    <div style="text-align: right; display: flex; gap: 1.5rem; align-items: flex-start;">
                        <!-- Prognose heute -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">📊 Prognose heute</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-purple);">
                                {{ forecast.todayTotal?.toFixed(2) || '—' }} kWh
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">Rest: {{ forecast.todayRemaining?.toFixed(2) || '—' }} kWh</div>
                        </div>
                        <!-- Tagesertrag -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">☀️ Tagesertrag</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-green);">
                                {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '—' }} kWh
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">Peak: {{ stats.peaks.today?.power_w?.toFixed(0) || '—' }} W</div>
                        </div>
                        <!-- Beste Stunde (Prognose) -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">🏆 Beste Stunde</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-yellow);">
                                {{ bestHour.hour !== null ? bestHour.hour + ':00' : '—' }}
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">{{ bestHour.prediction_kwh?.toFixed(2) || '—' }} kWh</div>
                        </div>
                    </div>
                </div>

                <!-- Complete SVG Energy Flow Diagram -->
                <svg class="energy-flow-svg" viewBox="0 0 500 320" preserveAspectRatio="xMidYMid meet">
                    <!-- Definitions -->
                    <defs>
                        <!-- Gradients -->
                        <linearGradient id="gradSolarHome" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stop-color="#ffdd00"/>
                            <stop offset="100%" stop-color="#00ffff"/>
                        </linearGradient>
                        <linearGradient id="gradSolarBattery" x1="100%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stop-color="#ffdd00"/>
                            <stop offset="100%" stop-color="#22c55e"/>
                        </linearGradient>
                        <linearGradient id="gradBatteryHome" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" stop-color="#22c55e"/>
                            <stop offset="100%" stop-color="#00ffff"/>
                        </linearGradient>
                        <linearGradient id="gradGridHome" x1="100%" y1="0%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#8b5cf6"/>
                            <stop offset="100%" stop-color="#00ffff"/>
                        </linearGradient>
                        <linearGradient id="gradGridBattery" x1="100%" y1="0%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#8b5cf6"/>
                            <stop offset="100%" stop-color="#22c55e"/>
                        </linearGradient>
                        <linearGradient id="gradHomeGrid" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" stop-color="#00ffff"/>
                            <stop offset="100%" stop-color="#8b5cf6"/>
                        </linearGradient>

                        <!-- Glow Filters -->
                        <filter id="glowYellow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowGreen" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowCyan" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowPurple" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                    </defs>

                    <!-- Node Positions: Solar(250,50), Battery(80,190), Home(250,190), Grid(420,190) -->

                    <!-- ========== FLOW LINES ========== -->
                    <!-- Solar to Home (vertical) -->
                    <path d="M250,90 L250,150"
                          stroke="#ffdd00" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.solar_to_house > 0 ? 1 : 0"/>

                    <!-- Solar to Battery (diagonal) -->
                    <path v-if="hasBattery" d="M215,75 L115,155"
                          stroke="#ffdd00" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.solar_to_battery > 0 ? 1 : 0"/>

                    <!-- Battery to Home (horizontal) -->
                    <path v-if="hasBattery" d="M120,190 L210,190"
                          stroke="#22c55e" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.battery_to_house > 0 ? 1 : 0"/>

                    <!-- Grid to Home (horizontal) - dashed when active -->
                    <path d="M378,190 L292,190"
                          stroke="#8b5cf6" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="5,5"
                          :opacity="energyFlow.flows.grid_to_house > 0 ? 1 : 0"/>

                    <!-- Grid to Battery (curved path below) -->
                    <path v-if="hasBattery" d="M380,220 Q250,340 120,220"
                          stroke="#8b5cf6" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="5,5"
                          :opacity="energyFlow.flows.grid_to_battery > 0 ? 1 : 0"/>

                    <!-- Home to Grid (Export) -->
                    <path d="M290,180 L380,180"
                          stroke="#00ffff" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.house_to_grid > 0 ? 1 : 0"/>

                    <!-- ========== ANIMATED PARTICLES ========== -->
                    <!-- Solar to Home -->
                    <circle v-if="energyFlow.flows.solar_to_house > 0" r="5" fill="#ffdd00" filter="url(#glowYellow)">
                        <animateMotion dur="1.2s" repeatCount="indefinite" path="M250,90 L250,150"/>
                    </circle>

                    <!-- Solar to Battery -->
                    <circle v-if="hasBattery && energyFlow.flows.solar_to_battery > 0" r="5" fill="#ffdd00" filter="url(#glowYellow)">
                        <animateMotion dur="1.5s" repeatCount="indefinite" path="M215,75 L115,155"/>
                    </circle>

                    <!-- Battery to Home -->
                    <circle v-if="hasBattery && energyFlow.flows.battery_to_house > 0" r="5" fill="#22c55e" filter="url(#glowGreen)">
                        <animateMotion dur="1.3s" repeatCount="indefinite" path="M120,190 L210,190"/>
                    </circle>

                    <!-- Grid to Home -->
                    <circle v-if="energyFlow.flows.grid_to_house > 0" r="5" fill="#8b5cf6" filter="url(#glowPurple)">
                        <animateMotion dur="1.3s" repeatCount="indefinite" path="M380,190 L290,190"/>
                    </circle>

                    <!-- Home to Grid -->
                    <circle v-if="energyFlow.flows.house_to_grid > 0" r="5" fill="#00ffff" filter="url(#glowCyan)">
                        <animateMotion dur="1.3s" repeatCount="indefinite" path="M290,180 L380,180"/>
                    </circle>

                    <!-- Grid to Battery -->
                    <circle v-if="hasBattery && energyFlow.flows.grid_to_battery > 0" r="4" fill="#8b5cf6" filter="url(#glowPurple)">
                        <animateMotion dur="2.5s" repeatCount="indefinite" path="M380,220 Q250,340 120,220"/>
                    </circle>

                    <!-- ========== FLOW LABELS (centered on lines) ========== -->
                    <!-- Solar to Home Label -->
                    <text v-if="energyFlow.flows.solar_to_house > 0" x="270" y="125"
                          fill="#ffdd00" font-size="11" font-weight="bold" text-anchor="start">
                        {{ energyFlow.flows.solar_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Solar to Battery Label -->
                    <text v-if="hasBattery && energyFlow.flows.solar_to_battery > 0" x="150" y="105"
                          fill="#ffdd00" font-size="11" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.solar_to_battery?.toFixed(0) }} W
                    </text>

                    <!-- Battery to Home Label -->
                    <text v-if="hasBattery && energyFlow.flows.battery_to_house > 0" x="165" y="182"
                          fill="#22c55e" font-size="11" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.battery_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Grid to Home Label -->
                    <text v-if="energyFlow.flows.grid_to_house > 0" x="335" y="182"
                          fill="#8b5cf6" font-size="11" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.grid_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Grid to Battery Label -->
                    <text v-if="energyFlow.flows.grid_to_battery > 0" x="250" y="300"
                          fill="#8b5cf6" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.grid_to_battery?.toFixed(0) }} W
                    </text>

                    <!-- Home to Grid (Export) Label -->
                    <text v-if="energyFlow.flows.house_to_grid > 0" x="335" y="173"
                          fill="#00ffff" font-size="11" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.house_to_grid?.toFixed(0) }} W
                    </text>

                    <!-- ========== SOLAR NODE (center top) - Realistic Sun ========== -->
                    <g class="node-glow-solar node-clickable" :class="{ active: energyFlow.flows.solar_power > 0 }" @click="openSolarModal">
                        <circle cx="250" cy="50" r="38" fill="rgba(251, 191, 36, 0.15)" stroke="#ffdd00" stroke-width="2"/>
                        <!-- Sun SVG Icon -->
                        <g transform="translate(250, 50)">
                            <!-- Sun core -->
                            <circle r="12" fill="#ffdd00"/>
                            <!-- Sun rays -->
                            <g stroke="#ffdd00" stroke-width="2.5" stroke-linecap="round">
                                <line x1="0" y1="-18" x2="0" y2="-24"/>
                                <line x1="0" y1="18" x2="0" y2="24"/>
                                <line x1="-18" y1="0" x2="-24" y2="0"/>
                                <line x1="18" y1="0" x2="24" y2="0"/>
                                <line x1="-13" y1="-13" x2="-17" y2="-17"/>
                                <line x1="13" y1="-13" x2="17" y2="-17"/>
                                <line x1="-13" y1="13" x2="-17" y2="17"/>
                                <line x1="13" y1="13" x2="17" y2="17"/>
                            </g>
                        </g>
                    </g>
                    <!-- Total Solar Power Display (right of sun) -->
                    <text x="300" y="55" fill="#ffdd00" font-size="18" font-weight="bold" text-anchor="start"
                          style="filter: drop-shadow(0 0 10px rgba(255, 221, 0, 0.9));">
                        {{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W
                    </text>

                    <!-- ========== BATTERY NODE (left) - Realistic Battery ========== -->
                    <g v-if="hasBattery" class="node-glow-battery node-clickable" :class="{ active: energyFlow.battery.power !== 0 }" @click="openBatteryModal">
                        <circle cx="80" cy="190" r="38" fill="rgba(34, 197, 94, 0.15)" stroke="#22c55e" stroke-width="2"/>
                        <!-- SOC Ring -->
                        <circle v-if="energyFlow.battery.soc !== null" cx="80" cy="190" r="42" fill="none"
                                stroke="rgba(34,197,94,0.2)" stroke-width="4"/>
                        <circle v-if="energyFlow.battery.soc !== null" cx="80" cy="190" r="42" fill="none"
                                stroke="#22c55e" stroke-width="4"
                                :stroke-dasharray="263.9"
                                :stroke-dashoffset="263.9 - (263.9 * (energyFlow.battery.soc || 0) / 100)"
                                stroke-linecap="round"
                                transform="rotate(-90 80 190)"/>
                        <!-- Battery SVG Icon -->
                        <g transform="translate(80, 190)">
                            <!-- Battery body -->
                            <rect x="-14" y="-18" width="28" height="36" rx="3" fill="none" stroke="#22c55e" stroke-width="2"/>
                            <!-- Battery top (positive terminal) -->
                            <rect x="-6" y="-22" width="12" height="4" rx="1" fill="#22c55e"/>
                            <!-- Battery level (dynamic based on SOC) -->
                            <rect x="-11" y="15" width="22" :height="Math.max(0, (energyFlow.battery.soc || 0) / 100 * 30)"
                                  :transform="'translate(0, ' + (-((energyFlow.battery.soc || 0) / 100 * 30)) + ')'"
                                  fill="#22c55e" opacity="0.6" rx="1"/>
                            <!-- Battery segments -->
                            <line x1="-11" y1="-5" x2="11" y2="-5" stroke="#22c55e" stroke-width="1" opacity="0.4"/>
                            <line x1="-11" y1="5" x2="11" y2="5" stroke="#22c55e" stroke-width="1" opacity="0.4"/>
                        </g>
                    </g>
                    <text v-if="hasBattery" x="80" y="250" fill="#22c55e" font-size="14" font-weight="bold" text-anchor="middle"
                          style="filter: drop-shadow(0 0 6px rgba(34, 197, 94, 0.7));">
                        {{ energyFlow.battery.soc?.toFixed(0) || '—' }} %
                    </text>
                    <text v-if="hasBattery" x="80" y="265" fill="#94a3b8" font-size="10" text-anchor="middle">Batterie</text>
                    <text v-if="hasBattery && energyFlow.battery.power" x="80" y="280" fill="#64748b" font-size="9" text-anchor="middle">
                        {{ energyFlow.battery.power > 0 ? '+' : '' }}{{ energyFlow.battery.power?.toFixed(0) }} W
                    </text>

                    <!-- ========== HOME NODE (center) - Realistic House ========== -->
                    <g class="node-glow-home node-clickable" :class="{ active: energyFlow.home.consumption > 0 }" @click="openHouseModal">
                        <circle cx="250" cy="190" r="38" fill="rgba(0, 255, 255, 0.15)" stroke="#00ffff" stroke-width="2"/>
                        <!-- House SVG Icon -->
                        <g transform="translate(250, 190)">
                            <!-- Roof -->
                            <path d="M-22,0 L0,-20 L22,0" fill="none" stroke="#00ffff" stroke-width="2.5" stroke-linejoin="round"/>
                            <!-- House body -->
                            <rect x="-18" y="0" width="36" height="22" fill="none" stroke="#00ffff" stroke-width="2"/>
                            <!-- Door -->
                            <rect x="-5" y="8" width="10" height="14" fill="rgba(0, 255, 255, 0.3)" stroke="#00ffff" stroke-width="1.5"/>
                            <!-- Window left -->
                            <rect x="-15" y="4" width="7" height="7" fill="rgba(0, 255, 255, 0.2)" stroke="#00ffff" stroke-width="1"/>
                            <!-- Window right -->
                            <rect x="8" y="4" width="7" height="7" fill="rgba(0, 255, 255, 0.2)" stroke="#00ffff" stroke-width="1"/>
                        </g>
                    </g>
                    <text x="250" y="250" fill="#00ffff" font-size="14" font-weight="bold" text-anchor="middle"
                          style="filter: drop-shadow(0 0 6px rgba(0, 255, 255, 0.7));">
                        {{ energyFlow.home.consumption?.toFixed(0) || '—' }} W
                    </text>
                    <text x="250" y="265" fill="#94a3b8" font-size="10" text-anchor="middle">Verbrauch</text>

                    <!-- ========== GRID NODE (right) - Power Pole / Strommast ========== -->
                    <g class="node-glow-grid node-clickable" :class="{ active: (energyFlow.flows.grid_to_house > 0 || energyFlow.flows.house_to_grid > 0) }" @click="openGridModal">
                        <circle cx="420" cy="190" r="38" fill="rgba(139, 92, 246, 0.15)" stroke="#8b5cf6" stroke-width="2"/>
                        <!-- Power Pole SVG Icon -->
                        <g transform="translate(420, 190)">
                            <!-- Main pole -->
                            <line x1="0" y1="-22" x2="0" y2="22" stroke="#8b5cf6" stroke-width="3"/>
                            <!-- Top cross arm -->
                            <line x1="-18" y1="-18" x2="18" y2="-18" stroke="#8b5cf6" stroke-width="2.5"/>
                            <!-- Middle cross arm -->
                            <line x1="-14" y1="-8" x2="14" y2="-8" stroke="#8b5cf6" stroke-width="2"/>
                            <!-- Insulators on top arm -->
                            <circle cx="-15" cy="-18" r="3" fill="#8b5cf6" opacity="0.6"/>
                            <circle cx="15" cy="-18" r="3" fill="#8b5cf6" opacity="0.6"/>
                            <circle cx="0" cy="-18" r="3" fill="#8b5cf6" opacity="0.6"/>
                            <!-- Insulators on middle arm -->
                            <circle cx="-11" cy="-8" r="2.5" fill="#8b5cf6" opacity="0.5"/>
                            <circle cx="11" cy="-8" r="2.5" fill="#8b5cf6" opacity="0.5"/>
                            <!-- Power lines going out (decorative) -->
                            <path d="M-15,-18 Q-25,-14 -25,-8" fill="none" stroke="#8b5cf6" stroke-width="1" opacity="0.5"/>
                            <path d="M15,-18 Q25,-14 25,-8" fill="none" stroke="#8b5cf6" stroke-width="1" opacity="0.5"/>
                        </g>
                    </g>
                    <text x="420" y="250" fill="#8b5cf6" font-size="14" font-weight="bold" text-anchor="middle"
                          style="filter: drop-shadow(0 0 6px rgba(139, 92, 246, 0.7));">
                        {{ getGridPower() }} W
                    </text>
                    <text x="420" y="265" fill="#94a3b8" font-size="10" text-anchor="middle">{{ getGridLabel() }}</text>
                    <text x="420" y="280" fill="#64748b" font-size="9" text-anchor="middle">
                        {{ currentPrice.total_price?.toFixed(2) || '—' }} ct/kWh
                    </text>
                </svg>
            </section>

            <!-- Solar Power Live Card - Header klickbar für Modal -->
            <section class="power-sources-card">
                <div class="power-sources-header" @click="openPowerSourcesModal" style="cursor: pointer;">
                    <div class="power-sources-title">
                        <span>☀️</span>
                        <span>Deflektorschild-Kollektor</span>
                        <span v-if="energyFlow.flows.solar_power !== null" style="margin-left: 12px; font-size: 1.3rem; color: #FFB74D;">{{ Math.round(energyFlow.flows.solar_power || 0) }} W</span>
                        <span v-if="stats.peaks.today?.power_w" style="margin-left: 16px; font-size: 0.85rem; color: #94a3b8;">
                            Peak: <span style="color: #4ade80;">{{ Math.round(stats.peaks.today.power_w) }} W</span>
                            <span v-if="stats.peaks.today?.at" style="color: #64748b;"> ({{ formatTime(stats.peaks.today.at) }})</span>
                        </span>
                    </div>
                    <div class="power-sources-subtitle">Klicken für Kollektor-Diagnostik • Live-Daten</div>
                </div>
                <div class="power-sources-chart-container" ref="powerSourcesPreviewChart"></div>
                <div class="power-sources-legend">
                    <div class="power-sources-legend-item">
                        <div class="power-sources-legend-dot solar"></div>
                        <span>PV-Leistung</span>
                    </div>
                </div>

                <!-- Panel Grid - Individuelle PV-Panels -->
                <div class="panel-grid" v-if="energyFlow.panels && energyFlow.panels.length > 0">
                    <div class="panel-card" v-for="panel in energyFlow.panels" :key="panel.id">
                        <div class="panel-card-header">
                            <!-- Solar Panel SVG Icon -->
                            <svg class="panel-card-icon" viewBox="0 0 24 24" fill="none" stroke="#ffdd00" stroke-width="1.5">
                                <rect x="3" y="6" width="18" height="12" rx="1" fill="rgba(255,221,0,0.2)"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                                <line x1="3" y1="14" x2="21" y2="14"/>
                                <line x1="9" y1="6" x2="9" y2="18"/>
                                <line x1="15" y1="6" x2="15" y2="18"/>
                                <circle cx="12" cy="3" r="1.5" fill="#ffdd00" stroke="none"/>
                                <line x1="12" y1="4.5" x2="12" y2="6" stroke="#ffdd00"/>
                            </svg>
                            <span class="panel-card-name">{{ panel.name }}</span>
                        </div>
                        <div class="panel-card-power">{{ panel.power?.toFixed(0) || '0' }} <span class="panel-card-unit">W</span></div>
                    </div>
                </div>
            </section>

            <!-- Prognose-Übersicht: Heute, Morgen, Übermorgen -->
            <section class="forecast-overview-container">
                <div class="forecast-overview-header">
                    <div class="forecast-overview-title">📡 Langstrecken-Scanner</div>
                    <div class="forecast-overview-subtitle">Energievorhersage für die nächsten 3 Sternentage</div>
                </div>
                <div class="forecast-days-grid">
                    <!-- Heute -->
                    <div class="forecast-day-card today">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">Heute</span>
                            <span class="forecast-day-total">{{ forecast.todayTotal?.toFixed(2) || '—' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail"><span style="color: var(--neon-green);">✓</span> Ertrag: {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0.00' }} kWh</span>
                            <span class="forecast-detail"><span style="color: var(--neon-cyan);">↻</span> Rest: {{ forecast.todayRemaining?.toFixed(2) || '0.00' }} kWh</span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.todayHours" :key="'today-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar today-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                        </div>
                    </div>
                    <!-- Morgen -->
                    <div class="forecast-day-card tomorrow">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">Morgen</span>
                            <span class="forecast-day-total">{{ forecast.tomorrowTotal?.toFixed(2) || '—' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail" v-if="forecast.tomorrowHours.length > 0">
                                <span style="color: var(--neon-yellow);">🏆</span> Beste: {{ Math.max(...forecast.tomorrowHours.map(h => h.kwh)).toFixed(2) }} kWh
                            </span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.tomorrowHours" :key="'tomorrow-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar tomorrow-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                            <div v-if="forecast.tomorrowHours.length === 0" class="forecast-no-data">Keine Daten</div>
                        </div>
                    </div>
                    <!-- Übermorgen -->
                    <div class="forecast-day-card day-after-tomorrow">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">Übermorgen</span>
                            <span class="forecast-day-total">{{ forecast.dayAfterTomorrowTotal?.toFixed(2) || '—' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail" v-if="forecast.dayAfterTomorrowHours.length > 0">
                                <span style="color: var(--neon-yellow);">🏆</span> Beste: {{ Math.max(...forecast.dayAfterTomorrowHours.map(h => h.kwh)).toFixed(2) }} kWh
                            </span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.dayAfterTomorrowHours" :key="'dayafter-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar dayafter-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                            <div v-if="forecast.dayAfterTomorrowHours.length === 0" class="forecast-no-data">Keine Daten</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Tagesproduktion Chart (direkt unter Energiefluss) -->
            <section class="chart-card" style="margin-bottom: var(--spacing-lg);">
                <div class="chart-header" @click="openProductionTodayModal" style="cursor: pointer;">
                    <div class="chart-title">📅 Tages-Energieertrag (Echtzeit-Scan)</div>
                    <div class="chart-stats">
                        <span class="chart-stat" style="color: #00ff88;">Ertrag: {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '—' }} kWh</span>
                        <span class="chart-stat" style="color: #8b5cf6;">Prognose: {{ forecast.todayTotal?.toFixed(2) || '—' }} kWh</span>
                        <span class="chart-stat" :style="{color: todayAccuracy >= 80 ? '#00ff88' : todayAccuracy >= 50 ? '#ffdd00' : '#ef4444'}">
                            Genauigkeit: {{ todayAccuracy?.toFixed(0) || '—' }}%
                        </span>
                    </div>
                </div>
                <div class="chart-container tall" ref="todayProductionChart"></div>
            </section>

            <!-- Panel-Gruppen Produktion (Prognose vs IST pro Gruppe) -->
            <section class="top-row" style="margin-bottom: var(--spacing-lg);" v-if="panelGroups.available">
                <template v-for="(group, groupName) in panelGroups.groups" :key="groupName">
                    <div class="chart-card" style="flex: 1; min-width: 300px;">
                        <div class="chart-header" @click="openPanelGroupModal(groupName)" style="cursor: pointer;">
                            <div class="chart-title">☀️ {{ groupName }}</div>
                            <div class="chart-stats">
                                <span class="chart-stat" style="color: #00ff88;">IST: {{ group.actual_total_kwh?.toFixed(3) || '0.000' }} kWh</span>
                                <span class="chart-stat" style="color: #8b5cf6;">Prognose: {{ group.prediction_total_kwh?.toFixed(3) || '0.000' }} kWh</span>
                                <span class="chart-stat" :style="{color: (group.accuracy_percent || 0) >= 80 ? '#00ff88' : (group.accuracy_percent || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                    {{ group.accuracy_percent?.toFixed(0) || '—' }}%
                                </span>
                            </div>
                        </div>
                        <div class="chart-container" :ref="el => panelGroupChartRefs[groupName] = el" style="height: 200px;"></div>
                    </div>
                </template>
            </section>

            <!-- Live Energy Flow Widgets - Stil wie Wetter -->
            <section class="top-row" style="margin-bottom: var(--spacing-lg);">
                <!-- Gruppe 1: Solar Live -->
                <div class="widget-group-container">
                    <span class="widget-group-label">☀️ Fusionsreaktor</span>
                    <!-- Solar → Haus -->
                    <div class="weather-widget" style="border-color: #ffdd00;">
                        <div class="weather-main">
                            <div class="weather-icon">☀️🏠</div>
                            <div>
                                <div class="weather-temp" style="color: #ffdd00;">{{ energyFlow.flows.solar_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Solar → Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>⚡</span><span>{{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W total</span></div>
                            <div class="weather-detail"><span>📊</span><span>{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0' }} kWh</span></div>
                        </div>
                    </div>
                    <!-- Solar → Akku -->
                    <div v-if="hasBattery" class="weather-widget" style="border-color: #ffdd00;">
                        <div class="weather-main">
                            <div class="weather-icon">☀️🔋</div>
                            <div>
                                <div class="weather-temp" style="color: #ffdd00;">{{ energyFlow.flows.solar_to_battery?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Solar → Akku</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>🔋</span><span>{{ energyFlow.battery.soc?.toFixed(0) || '0' }}% SOC</span></div>
                            <div class="weather-detail"><span>📈</span><span>{{ energyFlow.statistics.battery_charge_solar_daily?.toFixed(2) || '0' }} kWh</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 2: Akku Live (nur wenn Batterie vorhanden) -->
                <div v-if="hasBattery" class="widget-group-container">
                    <span class="widget-group-label">🔋 Dilithium-Kammer</span>
                    <!-- Akku → Haus -->
                    <div class="weather-widget" style="border-color: #22c55e;">
                        <div class="weather-main">
                            <div class="weather-icon">🔋🏠</div>
                            <div>
                                <div class="weather-temp" style="color: #22c55e;">{{ energyFlow.flows.battery_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Akku → Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>🔋</span><span>{{ energyFlow.battery.soc?.toFixed(0) || '0' }}% SOC</span></div>
                            <div class="weather-detail"><span>⚡</span><span>{{ energyFlow.battery.power?.toFixed(0) || '0' }} W</span></div>
                        </div>
                    </div>
                    <!-- Netz → Akku -->
                    <div class="weather-widget" style="border-color: #22c55e;">
                        <div class="weather-main">
                            <div class="weather-icon">⚡🔋</div>
                            <div>
                                <div class="weather-temp" style="color: #22c55e;">{{ energyFlow.flows.grid_to_battery?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Netz → Akku</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>📈</span><span>{{ energyFlow.statistics.battery_charge_grid_daily?.toFixed(2) || '0' }} kWh</span></div>
                            <div class="weather-detail"><span>💰</span><span>{{ currentPrice.total_price?.toFixed(2) || '—' }} ct/kWh</span></div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="top-row" style="margin-bottom: var(--spacing-lg);">
                <!-- Gruppe 3: Netz Live -->
                <div class="widget-group-container">
                    <span class="widget-group-label">⚡ Energienetz</span>
                    <!-- Netz → Haus -->
                    <div class="weather-widget" style="border-color: #8b5cf6;">
                        <div class="weather-main">
                            <div class="weather-icon">⚡🏠</div>
                            <div>
                                <div class="weather-temp" style="color: #8b5cf6;">{{ energyFlow.flows.grid_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Netz → Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>📊</span><span>{{ energyFlow.statistics.grid_import_daily?.toFixed(2) || '0' }} kWh heute</span></div>
                            <div class="weather-detail"><span>💰</span><span>{{ currentPrice.total_price?.toFixed(2) || '—' }} ct/kWh</span></div>
                        </div>
                    </div>
                    <!-- Einspeisung -->
                    <div class="weather-widget" style="border-color: #00ffff;">
                        <div class="weather-main">
                            <div class="weather-icon">🏠⚡</div>
                            <div>
                                <div class="weather-temp" style="color: #00ffff;">{{ energyFlow.flows.house_to_grid?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Einspeisung</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>🏠</span><span>{{ energyFlow.home.consumption?.toFixed(0) || '0' }} W Verbrauch</span></div>
                            <div class="weather-detail"><span>💵</span><span>{{ energyFlow.feed_in_tariff?.toFixed(1) || '8.1' }} ct/kWh Vergütung</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 4: Haus Live -->
                <div class="widget-group-container">
                    <span class="widget-group-label">🏠 Lebenserhaltung</span>
                    <!-- Verbrauch -->
                    <div class="weather-widget" style="border-color: #00ffff;">
                        <div class="weather-main">
                            <div class="weather-icon">🏠</div>
                            <div>
                                <div class="weather-temp" style="color: #00ffff;">{{ energyFlow.home.consumption?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Verbrauch</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>☀️</span><span>{{ energyFlow.flows.solar_to_house?.toFixed(0) || '0' }} W Solar</span></div>
                            <div v-if="hasBattery" class="weather-detail"><span>🔋</span><span>{{ energyFlow.flows.battery_to_house?.toFixed(0) || '0' }} W Akku</span></div>
                            <div class="weather-detail"><span>⚡</span><span>{{ energyFlow.flows.grid_to_house?.toFixed(0) || '0' }} W Netz</span></div>
                        </div>
                    </div>
                    <!-- Autarkie -->
                    <div class="weather-widget" style="border-color: #00ff88;">
                        <div class="weather-main">
                            <div class="weather-icon">🌱</div>
                            <div>
                                <div class="weather-temp" style="color: #00ff88;">{{ energyFlow.home.consumption > 0 ? Math.min(100, Math.max(0, (1 - (energyFlow.flows.grid_to_house || 0) / energyFlow.home.consumption) * 100)).toFixed(0) : '0' }}%</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Autarkie</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>☀️</span><span>{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0' }} kWh Ertrag</span></div>
                            <div class="weather-detail"><span>📊</span><span>{{ energyFlow.statistics.grid_import_daily?.toFixed(2) || '0' }} kWh Bezug</span></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ========== ENERGIE-BILANZ WIDGET (JAHRESBILANZ) ========== -->
            <section class="energy-balance-container">
                <div class="energy-balance-header">
                    <div class="energy-balance-title">
                        <span>💰</span> Sternenflotten-Abrechnung
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <a href="/api/sfml_stats/tariffs" class="tariff-link-btn" title="Monatliche Tarife verwalten (EEG/Energy Sharing)">
                            📊 Tarife
                        </a>
                        <div class="energy-balance-period">
                            <span v-if="energyBalance.periodStart">
                                📅 {{ energyBalance.periodStart }} bis {{ energyBalance.periodEnd }}
                            </span>
                            <span v-else>📅 Missions-Zeitraum</span>
                        </div>
                    </div>
                </div>

                <!-- Fortschrittsbalken für Abrechnungszeitraum -->
                <div style="margin-bottom: var(--spacing-md);">
                    <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">
                        <span>Tag {{ energyBalance.daysElapsed }} von {{ energyBalance.daysTotal }}</span>
                        <span>{{ energyBalance.periodProgress?.toFixed(0) || 0 }}% des Abrechnungsjahres</span>
                    </div>
                    <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                        <div :style="{width: energyBalance.periodProgress + '%', height: '100%', background: 'linear-gradient(90deg, #00ff88, #00ffff)', borderRadius: '3px', transition: 'width 0.5s'}"></div>
                    </div>
                </div>

                <!-- ===== BLOCK 1: HAUSHALT ===== -->
                <div style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-cyan); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>🏠</span> Gesamtverbrauch Haushalt
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item total">
                            <div class="energy-balance-icon">🏠</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.homeConsumption?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Gesamt</div>
                            <div class="energy-balance-sub">Verbrauch im Zeitraum</div>
                        </div>
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">☀️🏠</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Solar</div>
                            <div class="energy-balance-sub">Direktverbrauch</div>
                        </div>
                        <div class="energy-balance-item battery">
                            <div class="energy-balance-icon">🔋🏠</div>
                            <div class="energy-balance-value green">{{ energyBalance.batteryToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Akku</div>
                            <div class="energy-balance-sub">Aus Speicher</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">⚡🏠</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Netz</div>
                            <div class="energy-balance-sub">Bezahlt!</div>
                        </div>
                    </div>
                </div>

                <!-- ===== BLOCK 2: AKKU (nur wenn Batterie vorhanden) ===== -->
                <div v-if="hasBattery" style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-green); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>🔋</span> Gesamtladung Akku
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item battery">
                            <div class="energy-balance-icon">🔋</div>
                            <div class="energy-balance-value green">{{ energyBalance.batteryChargeTotal?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Gesamt</div>
                            <div class="energy-balance-sub">Geladen im Zeitraum</div>
                        </div>
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">☀️🔋</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarToBattery?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Solar</div>
                            <div class="energy-balance-sub">Kostenlos!</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">⚡🔋</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridToBattery?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Netz</div>
                            <div class="energy-balance-sub">Bezahlt!</div>
                        </div>
                    </div>
                </div>

                <!-- ===== BLOCK 3: GESAMT & FINANZEN ===== -->
                <div style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-yellow); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>📊</span> Übersicht & Finanzen
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">☀️</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarProduction?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Solar Gesamt</div>
                            <div class="energy-balance-sub">Ø {{ energyBalance.avgDailyProduction?.toFixed(1) || 0 }} kWh/Tag</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">⚡</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridImport?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Netz Gesamt</div>
                            <div class="energy-balance-sub">Haus + Akkuladung</div>
                        </div>
                        <div class="energy-balance-item grid" v-if="energyBalance.gridExport > 0">
                            <div class="energy-balance-icon">⚡↗️</div>
                            <div class="energy-balance-value cyan">{{ energyBalance.gridExport?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Einspeisung</div>
                            <div class="energy-balance-sub">Ins Netz</div>
                        </div>

                        <!-- Autarkie Donut -->
                        <div class="energy-balance-item autarkie autarkie-donut-container">
                            <div class="autarkie-donut">
                                <svg width="100" height="100" viewBox="0 0 120 120">
                                    <circle class="autarkie-donut-bg" cx="60" cy="60" r="50"/>
                                    <circle class="autarkie-donut-progress" cx="60" cy="60" r="50"
                                        :stroke-dasharray="314.16"
                                        :stroke-dashoffset="314.16 - (314.16 * (energyBalance.autarkiePercent || 0) / 100)"
                                        :style="{stroke: energyBalance.autarkiePercent >= 70 ? '#00ff88' : energyBalance.autarkiePercent >= 40 ? '#ffdd00' : '#8b5cf6'}"/>
                                </svg>
                                <div class="autarkie-donut-text">
                                    <div class="autarkie-donut-value" :style="{color: energyBalance.autarkiePercent >= 70 ? '#00ff88' : energyBalance.autarkiePercent >= 40 ? '#ffdd00' : '#8b5cf6'}">
                                        {{ energyBalance.autarkiePercent?.toFixed(0) || 0 }}%
                                    </div>
                                    <div class="autarkie-donut-label">Autarkie</div>
                                </div>
                            </div>
                        </div>

                        <div class="energy-balance-item cost">
                            <div class="energy-balance-icon">💰</div>
                            <div class="energy-balance-value purple">{{ energyBalance.estimatedCost?.toFixed(2) || '0.00' }}</div>
                            <div class="energy-balance-label">€ Stromkosten</div>
                            <div class="energy-balance-sub">Ø {{ energyBalance.avgPrice?.toFixed(1) || 35 }} ct/kWh</div>
                        </div>
                        <div class="energy-balance-item savings">
                            <div class="energy-balance-icon">💚</div>
                            <div class="energy-balance-value green">{{ energyBalance.savings?.toFixed(2) || '0.00' }}</div>
                            <div class="energy-balance-label">€ gespart</div>
                            <div class="energy-balance-sub">durch {{ energyBalance.savedKwh?.toFixed(0) || 0 }} kWh Solar</div>
                        </div>
                        <div class="energy-balance-item projection" v-if="energyBalance.projectedYearlySavings">
                            <div class="energy-balance-icon">📈</div>
                            <div class="energy-balance-value cyan">{{ energyBalance.projectedYearlySavings?.toFixed(0) || '—' }}</div>
                            <div class="energy-balance-label">€ Hochrechnung</div>
                            <div class="energy-balance-sub">Jahres-Ersparnis</div>
                        </div>
                    </div>
                </div>

                <!-- Recorder Info -->
                <div v-if="energyBalance.recorderAvailable" style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin-top: var(--spacing-sm);">
                    📊 {{ energyBalance.recorderSamples?.toLocaleString() || 0 }} Datenpunkte aus Recorder
                </div>

                <!-- Verbrauch-Breakdown Bar (Prozent-Anteile) -->
                <div class="energy-breakdown" v-if="energyBalance.homeConsumption > 0">
                    <div class="energy-breakdown-title">Stromherkunft im Zeitraum</div>
                    <div class="energy-breakdown-bar">
                        <div class="energy-breakdown-segment solar"
                             :style="{width: energyBalance.solarSelfPercent + '%'}"
                             v-if="energyBalance.solarSelfPercent > 3">
                            {{ energyBalance.solarSelfPercent?.toFixed(0) }}%
                        </div>
                        <div class="energy-breakdown-segment battery"
                             :style="{width: energyBalance.batteryPercent + '%'}"
                             v-if="energyBalance.batteryPercent > 3">
                            {{ energyBalance.batteryPercent?.toFixed(0) }}%
                        </div>
                        <div class="energy-breakdown-segment grid"
                             :style="{width: energyBalance.gridPercent + '%'}"
                             v-if="energyBalance.gridPercent > 3">
                            {{ energyBalance.gridPercent?.toFixed(0) }}%
                        </div>
                    </div>
                    <div class="energy-breakdown-legend">
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot solar"></span>
                            <span>Solar direkt</span>
                        </div>
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot battery"></span>
                            <span>Über Akku</span>
                        </div>
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot grid"></span>
                            <span>Aus Netz</span>
                        </div>
                    </div>
                </div>

                <!-- Hinweis zur Konfiguration -->
                <div v-if="!energyBalance.periodStart" style="margin-top: var(--spacing-md); padding: var(--spacing-sm); background: rgba(139, 92, 246, 0.1); border-radius: var(--radius-sm); font-size: 0.75rem; color: var(--text-muted); text-align: center;">
                    💡 Konfiguriere deinen Abrechnungszeitraum in den Integrationseinstellungen unter "Stromrechnung & Abrechnung"
                </div>
            </section>

            <!-- Statistics Cards - Sortiert: Heute > Woche > Monat > Jahr -->
            <section class="stats-container">
                <div class="stats-container-header">
                    <div>
                        <div class="stats-container-title">⚙️ Maschinenraum</div>
                        <div class="stats-container-subtitle">Energie-Systeme & Astronomische Sensoren</div>
                    </div>
                </div>
                <div class="stats-grid">

                <!-- ========== HEUTE ========== -->
                <div class="stat-card peak">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">⚡</span>
                        <span class="stat-card-badge">Heute</span>
                    </div>
                    <div class="stat-card-value">{{ stats.peaks.today?.power_w?.toFixed(0) || '—' }} W</div>
                    <div class="stat-card-label">Peak Leistung</div>
                    <div class="stat-card-sub" v-if="stats.peaks.today?.at">{{ formatTime(stats.peaks.today.at) }}</div>
                </div>

                <div class="stat-card grid" v-if="energyFlow.statistics.grid_import_daily !== null">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🔌</span>
                        <span class="stat-card-badge">Heute</span>
                    </div>
                    <div class="stat-card-value">{{ energyFlow.statistics.grid_import_daily?.toFixed(1) || '—' }} kWh</div>
                    <div class="stat-card-label">Netzbezug</div>
                </div>

                <div class="stat-card battery" v-if="energyFlow.statistics.battery_charge_solar_daily !== null">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🔋☀️</span>
                        <span class="stat-card-badge">Heute</span>
                    </div>
                    <div class="stat-card-value">{{ energyFlow.statistics.battery_charge_solar_daily?.toFixed(1) || '—' }} kWh</div>
                    <div class="stat-card-label">Akku aus Sonne</div>
                </div>

                <div class="stat-card battery" v-if="energyFlow.statistics.battery_charge_grid_daily !== null">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🔋⚡</span>
                        <span class="stat-card-badge">Heute</span>
                    </div>
                    <div class="stat-card-value">{{ energyFlow.statistics.battery_charge_grid_daily?.toFixed(1) || '—' }} kWh</div>
                    <div class="stat-card-label">Akku aus Netz</div>
                </div>

                <!-- ========== WOCHE ========== -->
                <div class="stat-card production">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">📅</span>
                        <span class="stat-card-badge">7 Tage</span>
                    </div>
                    <div class="stat-card-value">{{ stats.statistics.last_7_days?.total_yield_kwh?.toFixed(1) || '—' }} kWh</div>
                    <div class="stat-card-label">Wochenproduktion</div>
                    <div class="stat-card-sub">Ø {{ stats.statistics.last_7_days?.avg_yield_kwh?.toFixed(2) || '—' }} kWh/Tag</div>
                </div>

                <!-- ========== MONAT ========== -->
                <div class="stat-card production">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">📆</span>
                        <span class="stat-card-badge">Monat</span>
                    </div>
                    <div class="stat-card-value">{{ stats.statistics.current_month?.yield_kwh?.toFixed(1) || '—' }} kWh</div>
                    <div class="stat-card-label">Monatsproduktion</div>
                    <div class="stat-card-sub">{{ stats.statistics.current_month?.days || '—' }} Tage</div>
                </div>

                <!-- ========== JAHR / REKORD ========== -->
                <div class="stat-card grid" v-if="energyFlow.statistics.grid_import_yearly !== null">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">📊</span>
                        <span class="stat-card-badge">Jahr</span>
                    </div>
                    <div class="stat-card-value">{{ energyFlow.statistics.grid_import_yearly?.toFixed(0) || '—' }} kWh</div>
                    <div class="stat-card-label">Netzbezug Jahr</div>
                </div>

                <div class="stat-card peak">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🏆</span>
                        <span class="stat-card-badge">Rekord</span>
                    </div>
                    <div class="stat-card-value">{{ stats.peaks.all_time?.power_w?.toFixed(0) || '—' }} W</div>
                    <div class="stat-card-label">All-Time Peak</div>
                    <div class="stat-card-sub" v-if="stats.peaks.all_time?.date">{{ stats.peaks.all_time.date }}</div>
                </div>

                <!-- ========== ASTRONOMIE ========== -->
                <div class="stat-card astro">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🌞</span>
                        <span class="stat-card-badge">Astro</span>
                    </div>
                    <div class="stat-card-value">{{ sunPosition.elevation_deg?.toFixed(1) || '—' }}°</div>
                    <div class="stat-card-label">Sonnenhöhe</div>
                    <div class="stat-card-sub">{{ sunPosition.direction || '—' }} ({{ sunPosition.azimuth_deg?.toFixed(0) || '—' }}°)</div>
                </div>

                <div class="stat-card astro">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">🌅</span>
                        <span class="stat-card-badge">Astro</span>
                    </div>
                    <div class="stat-card-value">{{ sunPosition.sunrise || '—' }}</div>
                    <div class="stat-card-label">Sonnenaufgang</div>
                    <div class="stat-card-sub">🌇 {{ sunPosition.sunset || '—' }}</div>
                </div>

                <div class="stat-card astro">
                    <div class="stat-card-header">
                        <span class="stat-card-icon">☀️</span>
                        <span class="stat-card-badge">Astro</span>
                    </div>
                    <div class="stat-card-value">{{ sunPosition.daylight_hours?.toFixed(1) || '—' }}h</div>
                    <div class="stat-card-label">Tageslicht</div>
                </div>

                </div>
            </section>

            <!-- KPIs -->
            <section class="kpi-grid">
                <div class="kpi-card solar">
                    <div class="kpi-value">{{ kpis.weekProduction?.toFixed(2) || '—' }}</div>
                    <div class="kpi-label">kWh diese Woche</div>
                </div>
                <div class="kpi-card accuracy">
                    <div class="kpi-value">{{ kpis.avgAccuracy?.toFixed(0) || '—' }}%</div>
                    <div class="kpi-label">Ø Genauigkeit</div>
                </div>
                <div class="kpi-card price">
                    <div class="kpi-value">{{ kpis.priceMin?.toFixed(0) || '—' }}-{{ kpis.priceMax?.toFixed(0) || '—' }}</div>
                    <div class="kpi-label">ct/kWh Spanne</div>
                </div>
                <div class="kpi-card forecast">
                    <div class="kpi-value">{{ kpis.forecastWeek?.toFixed(1) || '—' }}</div>
                    <div class="kpi-label">kWh Prognose</div>
                </div>
            </section>

            <!-- Charts -->
            <section class="charts-grid">
                <div class="chart-card">
                    <div class="chart-title">Produktion vs. Vorhersage</div>
                    <div class="chart-container" ref="productionChart"></div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">📊 Prognose-Abweichung (0 = Treffer)</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #00ff88;">+ Mehr produziert als prognostiziert</span>
                            <span class="chart-stat" style="color: #ef4444;">− Weniger produziert</span>
                        </div>
                    </div>
                    <div class="chart-container" ref="accuracyChart"></div>
                </div>
                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">Strompreise Heute vs. Morgen (Endpreis)</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #ff0080;">Heute: {{ priceStats.min }}-{{ priceStats.max }} ct</span>
                            <span class="chart-stat" style="color: #00ffff;">Morgen: {{ priceStatsTomorrow.min }}-{{ priceStatsTomorrow.max }} ct</span>
                        </div>
                    </div>
                    <div class="chart-container" ref="priceChart"></div>
                </div>
                <div class="chart-card full-width">
                    <div class="chart-title">Wochenverlauf</div>
                    <div class="chart-container tall" ref="timelineChart"></div>
                </div>
            </section>

            <!-- Erweiterte Analyse-Charts -->
            <section class="charts-grid" style="margin-top: var(--spacing-lg);">
                <div class="chart-card full-width">
                    <div class="chart-header">
                        <div class="chart-title">📈 Langzeit-Trend (30 Tage)</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #00ff88;">Ø Produktion: {{ historyStats.avgProduction?.toFixed(2) || '—' }} kWh/Tag</span>
                            <span class="chart-stat" style="color: #8b5cf6;">Ø Prognose: {{ historyStats.avgForecast?.toFixed(2) || '—' }} kWh/Tag</span>
                        </div>
                    </div>
                    <div class="chart-container tall" ref="trendChart"></div>
                </div>
                <div class="chart-card full-width">
                    <div class="chart-header">
                        <div class="chart-title">📅 Monats-Vergleich</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #00ff88;">Gesamt: {{ historyStats.totalProduction?.toFixed(1) || '—' }} kWh</span>
                        </div>
                    </div>
                    <div class="chart-container" ref="monthlyChart"></div>
                </div>
            </section>
        </main>

        <!-- Solar Analytics Modal -->
        <div v-if="solarModal.isOpen" class="modal-overlay" @click.self="closeSolarModal">
            <div class="modal-container">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>☀️</span>
                        <span>Solar Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportSolarAnalytics" :disabled="solarModal.exporting">
                            <span v-if="!solarModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeSolarModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.weekTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Diese Woche</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.monthTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Dieser Monat</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.yearTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Dieses Jahr</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.avgAccuracy?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Ø Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.peakPower?.toFixed(0) || '—' }} W</div>
                            <div class="modal-stat-label">Peak Leistung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.avgDaily?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Ø pro Tag</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'week' }" @click="solarModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'month' }" @click="solarModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'year' }" @click="solarModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Production Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>📊</span>
                                <span>Produktion vs. Prognose</span>
                            </div>
                            <div id="solar-production-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Peak Times Heatmap -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🔥</span>
                                <span>Peak-Zeiten Heatmap</span>
                            </div>
                            <div id="solar-heatmap-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Accuracy Timeline -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🎯</span>
                                <span>Prognose-Genauigkeit</span>
                            </div>
                            <div id="solar-accuracy-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Panel Group Performance -->
                        <div class="modal-chart-container" v-if="panelGroups.available">
                            <div class="modal-chart-title">
                                <span>⚡</span>
                                <span>Panel-Gruppen Performance</span>
                            </div>
                            <div id="solar-panel-group-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== BATTERY MODAL ===== -->
        <div v-if="batteryModal.isOpen" class="modal-overlay" @click.self="closeBatteryModal">
            <div class="modal-container battery-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>🔋</span>
                        <span>Battery Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportBatteryAnalytics" :disabled="batteryModal.exporting">
                            <span v-if="!batteryModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeBatteryModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.weekCharged?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Geladen (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.weekDischarged?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Entladen (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.avgSOC?.toFixed(0) || '—' }}%</div>
                            <div class="modal-stat-label">Ø SOC</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.efficiency?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Wirkungsgrad</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.cycles?.toFixed(1) || '—' }}</div>
                            <div class="modal-stat-label">Zyklen (Monat)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.peakPower?.toFixed(0) || '—' }} W</div>
                            <div class="modal-stat-label">Peak Leistung</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'week' }" @click="batteryModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'month' }" @click="batteryModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'year' }" @click="batteryModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- SOC Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>📊</span>
                                <span>SOC Verlauf</span>
                            </div>
                            <div id="battery-soc-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Charge/Discharge Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>⚡</span>
                                <span>Laden / Entladen</span>
                            </div>
                            <div id="battery-charge-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Efficiency Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🎯</span>
                                <span>Wirkungsgrad</span>
                            </div>
                            <div id="battery-efficiency-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Power Distribution -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>📈</span>
                                <span>Leistungsverteilung</span>
                            </div>
                            <div id="battery-power-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== HOUSE MODAL ===== -->
        <div v-if="houseModal.isOpen" class="modal-overlay" @click.self="closeHouseModal">
            <div class="modal-container house-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>🏠</span>
                        <span>Haus Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportHouseAnalytics" :disabled="houseModal.exporting">
                            <span v-if="!houseModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeHouseModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.weekConsumption?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Verbrauch (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.avgDaily?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Ø pro Tag</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.autarky?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Autarkie</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.selfConsumption?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Eigenverbrauch</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.solarCoverage?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Solar-Abdeckung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.peakPower?.toFixed(0) || '—' }} W</div>
                            <div class="modal-stat-label">Peak Verbrauch</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'week' }" @click="houseModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'month' }" @click="houseModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'year' }" @click="houseModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Consumption Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>📊</span>
                                <span>Verbrauch Timeline</span>
                            </div>
                            <div id="house-consumption-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Autarky Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🎯</span>
                                <span>Autarkie & Eigenverbrauch</span>
                            </div>
                            <div id="house-autarky-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Energy Sources -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>⚡</span>
                                <span>Energiequellen</span>
                            </div>
                            <div id="house-sources-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Peak Times -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🔥</span>
                                <span>Verbrauch Peak-Zeiten</span>
                            </div>
                            <div id="house-peak-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== GRID MODAL ===== -->
        <div v-if="gridModal.isOpen" class="modal-overlay" @click.self="closeGridModal">
            <div class="modal-container grid-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>⚡</span>
                        <span>Netz Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportGridAnalytics" :disabled="gridModal.exporting">
                            <span v-if="!gridModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeGridModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.weekImport?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Bezug (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.weekExport?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Einspeisung (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.netBalance?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Netto Balance</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.avgPrice?.toFixed(2) || '—' }} ct/kWh</div>
                            <div class="modal-stat-label">Ø Strompreis</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.costs?.toFixed(2) || '—' }} €</div>
                            <div class="modal-stat-label">Kosten (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.revenue?.toFixed(2) || '—' }} €</div>
                            <div class="modal-stat-label">Erlöse (Mo-So)</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'week' }" @click="gridModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'month' }" @click="gridModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'year' }" @click="gridModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Import/Export Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>📊</span>
                                <span>Bezug / Einspeisung</span>
                            </div>
                            <div id="grid-flow-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Price Timeline -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>💰</span>
                                <span>Strompreis Verlauf</span>
                            </div>
                            <div id="grid-price-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Cost/Revenue Analysis -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>💶</span>
                                <span>Kosten / Erlöse</span>
                            </div>
                            <div id="grid-money-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Usage Patterns -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🔥</span>
                                <span>Nutzungsmuster</span>
                            </div>
                            <div id="grid-pattern-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== POWER SOURCES MODAL ===== -->
        <div v-if="powerSourcesModal.isOpen" class="modal-overlay" @click.self="closePowerSourcesModal">
            <div class="modal-container power-sources-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>⚡</span>
                        <span>Energiequellen Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportPowerSourcesAnalytics" :disabled="powerSourcesModal.exporting">
                            <span v-if="!powerSourcesModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closePowerSourcesModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats - 7 Cards -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #FFD700;">{{ powerSourcesModal.stats.solarTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Solar gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #FFB74D;">{{ powerSourcesModal.stats.solarToHouse?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Solar → Haus</div>
                        </div>
                        <div v-if="hasBattery" class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #9ACD32;">{{ powerSourcesModal.stats.solarToBattery?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Solar → Batterie</div>
                        </div>
                        <div v-if="hasBattery" class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #4DD0E1;">{{ powerSourcesModal.stats.batteryTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Batterie → Haus</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #90CAF9;">{{ powerSourcesModal.stats.gridTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Netz → Haus</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #FF8C00;">{{ powerSourcesModal.stats.consumptionTotal?.toFixed(2) || '—' }} kWh</div>
                            <div class="modal-stat-label">Verbrauch gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: var(--neon-green);">{{ powerSourcesModal.stats.autarky?.toFixed(1) || '—' }}%</div>
                            <div class="modal-stat-label">Autarkie</div>
                        </div>
                    </div>

                    <!-- Tabs and Date Picker -->
                    <div class="modal-tabs" style="flex-wrap: wrap; gap: 8px;">
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'today' }" @click="changePowerSourcesTab('today')">
                            Heute
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'yesterday' }" @click="changePowerSourcesTab('yesterday')">
                            Gestern
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'week' }" @click="changePowerSourcesTab('week')">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'custom' }" @click="changePowerSourcesTab('custom')" style="border-color: #8b5cf6;">
                            📅 Benutzerdefiniert
                        </button>
                    </div>

                    <!-- Custom Date Range Picker -->
                    <div v-if="powerSourcesModal.activeTab === 'custom'" class="date-range-picker" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px; background: rgba(139, 92, 246, 0.1); border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.3);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="color: #94a3b8; font-size: 0.85rem;">Von:</label>
                            <input type="date" v-model="powerSourcesModal.customStartDate"
                                   style="background: #1e1e3e; border: 1px solid #404040; color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 0.9rem;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="color: #94a3b8; font-size: 0.85rem;">Bis:</label>
                            <input type="date" v-model="powerSourcesModal.customEndDate"
                                   style="background: #1e1e3e; border: 1px solid #404040; color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 0.9rem;">
                        </div>
                        <button @click="loadPowerSourcesCustomRange"
                                style="background: linear-gradient(135deg, #8b5cf6, #6366f1); color: #fff; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            Laden
                        </button>
                    </div>

                    <!-- Main Chart -->
                    <div class="modal-chart-grid">
                        <!-- Stacked Area Chart -->
                        <div class="modal-chart-container" style="grid-column: 1 / -1;">
                            <div class="modal-chart-title">
                                <span>📊</span>
                                <span>Energiequellen im Zeitverlauf</span>
                            </div>
                            <div id="power-sources-main-chart" style="height: 450px;"></div>
                        </div>

                        <!-- Battery SOC -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🔋</span>
                                <span>Batterie-Ladestand</span>
                            </div>
                            <div id="power-sources-soc-chart" style="height: 250px;"></div>
                        </div>

                        <!-- Energy Distribution Pie -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🥧</span>
                                <span>Energieverteilung</span>
                            </div>
                            <div id="power-sources-pie-chart" style="height: 250px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== PANEL GROUP MODAL ===== -->
        <div v-if="panelGroupModal.isOpen" class="modal-overlay" @click.self="closePanelGroupModal">
            <div class="modal-container" style="max-width: 800px;">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>☀️</span>
                        <span>{{ panelGroupModal.groupName }} - Details</span>
                    </h2>
                    <button class="modal-close" @click="closePanelGroupModal">×</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); margin-bottom: 20px;">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #00ff88;">{{ panelGroupModal.groupData?.actual_total_kwh?.toFixed(3) || '0.000' }} kWh</div>
                            <div class="modal-stat-label">IST Gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #8b5cf6;">{{ panelGroupModal.groupData?.prediction_total_kwh?.toFixed(3) || '0.000' }} kWh</div>
                            <div class="modal-stat-label">Prognose Gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: (panelGroupModal.groupData?.accuracy_percent || 0) >= 80 ? '#00ff88' : (panelGroupModal.groupData?.accuracy_percent || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                {{ panelGroupModal.groupData?.accuracy_percent?.toFixed(1) || '—' }}%
                            </div>
                            <div class="modal-stat-label">Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: getPanelGroupDeviation() >= 0 ? '#00ff88' : '#ef4444'}">
                                {{ getPanelGroupDeviation() >= 0 ? '+' : '' }}{{ getPanelGroupDeviation()?.toFixed(1) || '0.0' }}%
                            </div>
                            <div class="modal-stat-label">Abweichung</div>
                        </div>
                    </div>

                    <!-- Hourly Data Table -->
                    <div class="modal-chart-container">
                        <div class="modal-chart-title">
                            <span>📊</span>
                            <span>Stündliche Übersicht</span>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                                <thead style="position: sticky; top: 0; background: #1e1e3e;">
                                    <tr style="border-bottom: 2px solid #404040;">
                                        <th style="padding: 10px; text-align: left; color: #94a3b8;">Stunde</th>
                                        <th style="padding: 10px; text-align: right; color: #00ff88;">IST (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #8b5cf6;">Prognose (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Abweichung</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="hour in getPanelGroupHourlyData()" :key="hour.hour"
                                        style="border-bottom: 1px solid #2a2a4a;"
                                        :style="{ background: hour.hour === new Date().getHours() ? 'rgba(255, 221, 0, 0.1)' : 'transparent' }">
                                        <td style="padding: 8px 10px; color: #e2e8f0;">
                                            {{ hour.hour }}:00
                                            <span v-if="hour.hour === new Date().getHours()" style="color: #ffdd00; font-size: 0.8rem;"> (aktuell)</span>
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #00ff88; font-family: monospace;">
                                            {{ hour.actual?.toFixed(4) || '0.0000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #8b5cf6; font-family: monospace;">
                                            {{ hour.prediction?.toFixed(4) || '0.0000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.deviation >= 0 ? '#00ff88' : '#ef4444' }">
                                            {{ hour.deviation >= 0 ? '+' : '' }}{{ hour.deviation?.toFixed(1) || '0.0' }}%
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== PRODUCTION TODAY MODAL ===== -->
        <div v-if="productionTodayModal.isOpen" class="modal-overlay" @click.self="closeProductionTodayModal">
            <div class="modal-container" style="max-width: 900px;">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>📅</span>
                        <span>Produktion Heute - Details</span>
                    </h2>
                    <button class="modal-close" @click="closeProductionTodayModal">×</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); margin-bottom: 20px;">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #00ff88;">{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Ertrag Heute</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #8b5cf6;">{{ forecast.todayTotal?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Prognose Heute</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: (todayAccuracy || 0) >= 80 ? '#00ff88' : (todayAccuracy || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                {{ todayAccuracy?.toFixed(1) || '—' }}%
                            </div>
                            <div class="modal-stat-label">Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: getProductionTodayDeviation() >= 0 ? '#00ff88' : '#ef4444'}">
                                {{ getProductionTodayDeviation() >= 0 ? '+' : '' }}{{ getProductionTodayDeviation()?.toFixed(1) || '0.0' }}%
                            </div>
                            <div class="modal-stat-label">Abweichung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #ffdd00;">{{ forecast.todayRemaining?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Verbleibend</div>
                        </div>
                    </div>

                    <!-- Hourly Data Table -->
                    <div class="modal-chart-container">
                        <div class="modal-chart-title">
                            <span>📊</span>
                            <span>Stündliche Übersicht</span>
                        </div>
                        <div style="max-height: 450px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                                <thead style="position: sticky; top: 0; background: #1e1e3e;">
                                    <tr style="border-bottom: 2px solid #404040;">
                                        <th style="padding: 10px; text-align: left; color: #94a3b8;">Stunde</th>
                                        <th style="padding: 10px; text-align: right; color: #00ff88;">IST (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #8b5cf6;">Prognose (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Abweichung</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Genauigkeit</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="hour in getProductionTodayHourlyData()" :key="hour.hour"
                                        style="border-bottom: 1px solid #2a2a4a;"
                                        :style="{ background: hour.hour === new Date().getHours() ? 'rgba(255, 221, 0, 0.1)' : 'transparent' }">
                                        <td style="padding: 8px 10px; color: #e2e8f0;">
                                            {{ hour.hour }}:00
                                            <span v-if="hour.hour === new Date().getHours()" style="color: #ffdd00; font-size: 0.8rem;"> (aktuell)</span>
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #00ff88; font-family: monospace;">
                                            {{ hour.actual?.toFixed(3) || '0.000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #8b5cf6; font-family: monospace;">
                                            {{ hour.prediction?.toFixed(3) || '0.000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.deviation >= 0 ? '#00ff88' : '#ef4444' }">
                                            {{ hour.deviation >= 0 ? '+' : '' }}{{ hour.deviation?.toFixed(1) || '0.0' }}%
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.accuracy >= 80 ? '#00ff88' : hour.accuracy >= 50 ? '#ffdd00' : '#ef4444' }">
                                            {{ hour.accuracy?.toFixed(0) || '—' }}%
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== WEATHER MODAL ===== -->
        <div v-if="weatherModal.isOpen" class="modal-overlay" @click.self="closeWeatherModal">
            <div class="modal-container weather-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>🌤️</span>
                        <span>Wetter Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportWeatherAnalytics" :disabled="weatherModal.exporting">
                            <span v-if="!weatherModal.exporting">📊 PNG Export</span>
                            <span v-else>⏳ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeWeatherModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.avgTemp?.toFixed(1) || '—' }}°C</div>
                            <div class="modal-stat-label">Ø Temperatur (Woche)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.maxTemp?.toFixed(1) || '—' }}°C</div>
                            <div class="modal-stat-label">Höchsttemperatur</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.minTemp?.toFixed(1) || '—' }}°C</div>
                            <div class="modal-stat-label">Tiefsttemperatur</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.totalRain?.toFixed(1) || '—' }} mm</div>
                            <div class="modal-stat-label">Niederschlag (Monat)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.avgWind?.toFixed(1) || '—' }} m/s</div>
                            <div class="modal-stat-label">Ø Wind</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.sunHours?.toFixed(0) || '—' }} h</div>
                            <div class="modal-stat-label">Sonnenstunden (Monat)</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'week' }" @click="weatherModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'month' }" @click="weatherModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'year' }" @click="weatherModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'comparison' }" @click="weatherModal.activeTab = 'comparison'" style="border-color: #8b5cf6;">
                            🤖 IST vs KI
                        </button>
                    </div>

                    <!-- Historical Charts (Week/Month/Year) -->
                    <div v-if="weatherModal.activeTab !== 'comparison'" class="modal-chart-grid">
                        <!-- Temperature Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🌡️</span>
                                <span>Temperatur Verlauf</span>
                            </div>
                            <div id="weather-temp-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Radiation & Solar Correlation -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>☀️</span>
                                <span>Einstrahlung & Solar-Produktion</span>
                            </div>
                            <div id="weather-radiation-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Rain & Humidity -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>💧</span>
                                <span>Niederschlag & Luftfeuchtigkeit</span>
                            </div>
                            <div id="weather-rain-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Wind Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🌬️</span>
                                <span>Wind Geschwindigkeit</span>
                            </div>
                            <div id="weather-wind-chart" style="height: 350px;"></div>
                        </div>
                    </div>

                    <!-- IST vs KI Comparison Charts -->
                    <div v-if="weatherModal.activeTab === 'comparison'" class="modal-chart-grid">
                        <!-- Temperature IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🌡️</span>
                                <span>Temperatur: IST vs KI</span>
                            </div>
                            <div id="weather-temp-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Radiation IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>☀️</span>
                                <span>Einstrahlung (W/m²): IST vs KI</span>
                            </div>
                            <div id="weather-radiation-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Clouds IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>☁️</span>
                                <span>Wolken (%): IST vs KI</span>
                            </div>
                            <div id="weather-clouds-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Accuracy Analysis -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>🎯</span>
                                <span>KI-Genauigkeit</span>
                            </div>
                            <div id="weather-accuracy-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== CLOTHING RECOMMENDATION MODAL ===== -->
        <div v-if="clothingModal.isOpen" class="modal-overlay" @click.self="closeClothingModal">
            <div class="modal-container clothing-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>👔</span>
                        <span>{{ clothingModal.title }}</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-close" @click="closeClothingModal">×</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Weather Summary -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.temperature?.toFixed(1) || '—' }}°C</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.temperature }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.feels_like?.toFixed(1) || '—' }}°C</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.feels_like }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.humidity?.toFixed(0) || '—' }}%</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.humidity }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.wind_speed?.toFixed(1) || '—' }} km/h</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.wind }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.rain_probability || '—' }}%</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.rain_prob }}</div>
                        </div>
                    </div>

                    <!-- Recommendation Text -->
                    <div class="clothing-text-container">
                        <p class="clothing-recommendation-text">{{ clothingModal.text }}</p>
                    </div>

                    <!-- Clothing Items Grid -->
                    <div class="clothing-items-grid">
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.unterbekleidung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.unterbekleidung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.pants }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.oberbekleidung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.oberbekleidung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.top }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.jacke?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.jacke?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.jacket }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.kopfbedeckung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.kopfbedeckung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.headwear }}</div>
                        </div>
                    </div>

                    <!-- Accessories -->
                    <div class="clothing-accessories" v-if="clothingModal.recommendation.zusaetze?.length > 0">
                        <div class="clothing-accessories-title">{{ clothingModal.labels.accessories }}</div>
                        <div class="clothing-accessories-list">
                            <span class="clothing-accessory" v-for="(item, index) in clothingModal.recommendation.zusaetze" :key="index">
                                {{ item.icon }} {{ item.name }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <div class="footer-tags">
                <span class="footer-tag">ML-Powered</span>
                <span class="footer-tag">Real-Time</span>
                <span class="footer-tag">Local</span>
            </div>
            <span>SFML Stats v2.0</span>
        </footer>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch } = Vue;

        // ============================================================
        // Toast Notification System
        // ============================================================
        const Toast = {
            container: null,

            init() {
                this.container = document.getElementById('toast-container');
            },

            show(message, type = 'info', title = null, duration = 5000) {
                if (!this.container) this.init();

                const icons = {
                    success: '✓',
                    error: '✕',
                    warning: '⚠',
                    info: 'ℹ'
                };

                const titles = {
                    success: 'Erfolg',
                    error: 'Fehler',
                    warning: 'Warnung',
                    info: 'Info'
                };

                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icons[type] || icons.info}</span>
                    <div class="toast-content">
                        <div class="toast-title">${title || titles[type]}</div>
                        <div class="toast-message">${message}</div>
                    </div>
                    <button class="toast-close" onclick="this.parentElement.remove()">×</button>
                `;

                this.container.appendChild(toast);

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        toast.classList.add('toast-exit');
                        setTimeout(() => toast.remove(), 300);
                    }, duration);
                }

                return toast;
            },

            success(message, title = null) {
                return this.show(message, 'success', title, 4000);
            },

            error(message, title = null) {
                return this.show(message, 'error', title, 8000);
            },

            warning(message, title = null) {
                return this.show(message, 'warning', title, 6000);
            },

            info(message, title = null) {
                return this.show(message, 'info', title, 5000);
            }
        };

        // ============================================================
        // API Client with Caching
        // ============================================================
        const SFMLApi = {
            cache: new Map(),
            cacheTTL: 30000, // 30 seconds default TTL
            pendingRequests: new Map(), // Prevent duplicate concurrent requests

            async fetch(endpoint, options = {}) {
                const {
                    useCache = true,
                    cacheTTL = this.cacheTTL,
                    showError = true,
                    method = 'GET',
                    body = null
                } = options;

                const url = endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`;
                const cacheKey = `${method}:${url}`;

                // Check cache for GET requests
                if (method === 'GET' && useCache) {
                    const cached = this.cache.get(cacheKey);
                    if (cached && Date.now() - cached.time < cacheTTL) {
                        return cached.data;
                    }
                }

                // Prevent duplicate concurrent requests
                if (method === 'GET' && this.pendingRequests.has(cacheKey)) {
                    return this.pendingRequests.get(cacheKey);
                }

                const fetchPromise = (async () => {
                    try {
                        const fetchOptions = { method };
                        if (body) {
                            fetchOptions.body = JSON.stringify(body);
                            fetchOptions.headers = { 'Content-Type': 'application/json' };
                        }

                        const response = await fetch(url, fetchOptions);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const contentType = response.headers.get('content-type');
                        let data;

                        if (contentType && contentType.includes('application/json')) {
                            data = await response.json();
                        } else {
                            // Handle blob responses (for file downloads)
                            data = await response.blob();
                        }

                        // Cache successful GET responses
                        if (method === 'GET' && useCache) {
                            this.cache.set(cacheKey, { data, time: Date.now() });
                        }

                        return data;
                    } catch (error) {
                        console.error(`API Error [${url}]:`, error);
                        if (showError) {
                            Toast.error(error.message, 'API-Fehler');
                        }
                        throw error;
                    } finally {
                        this.pendingRequests.delete(cacheKey);
                    }
                })();

                if (method === 'GET') {
                    this.pendingRequests.set(cacheKey, fetchPromise);
                }

                return fetchPromise;
            },

            // Convenience methods
            async get(endpoint, options = {}) {
                return this.fetch(endpoint, { ...options, method: 'GET' });
            },

            async post(endpoint, body, options = {}) {
                return this.fetch(endpoint, { ...options, method: 'POST', body });
            },

            // Clear cache
            clearCache(endpoint = null) {
                if (endpoint) {
                    const url = endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`;
                    this.cache.delete(`GET:${url}`);
                } else {
                    this.cache.clear();
                }
            },

            // Download helper for exports
            async download(endpoint, filename) {
                try {
                    Toast.info('Export wird vorbereitet...', 'Download');

                    const response = await fetch(
                        endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`
                    );

                    if (!response.ok) {
                        throw new Error(`Export fehlgeschlagen: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    Toast.success(`${filename} wurde heruntergeladen`, 'Export erfolgreich');
                    return true;
                } catch (error) {
                    console.error('Download error:', error);
                    Toast.error(error.message, 'Export fehlgeschlagen');
                    throw error;
                }
            }
        };

        // ============================================================
        // Loading State Helper
        // ============================================================
        function createLoadingState() {
            const isLoading = ref(false);
            const error = ref(null);

            async function withLoading(asyncFn) {
                isLoading.value = true;
                error.value = null;
                try {
                    return await asyncFn();
                } catch (e) {
                    error.value = e.message;
                    throw e;
                } finally {
                    isLoading.value = false;
                }
            }

            return { isLoading, error, withLoading };
        }

        createApp({
            setup() {
                const lastUpdate = ref('—');

                // Theme Toggle
                const isDarkTheme = ref(localStorage.getItem('sfml-theme') !== 'light');

                function toggleTheme() {
                    isDarkTheme.value = !isDarkTheme.value;
                    if (isDarkTheme.value) {
                        document.documentElement.classList.remove('light-theme');
                        localStorage.setItem('sfml-theme', 'dark');
                    } else {
                        document.documentElement.classList.add('light-theme');
                        localStorage.setItem('sfml-theme', 'light');
                    }
                }

                // Initialize theme on load
                if (!isDarkTheme.value) {
                    document.documentElement.classList.add('light-theme');
                }
                const weather = reactive({ temperature: null, radiation: null, humidity: null, wind: null, clouds: null });
                const weatherCorrected = reactive({ temperature: null, radiation: null, humidity: null, wind: null, clouds: null });
                const weatherHA = reactive({ state: null, temperature: null, humidity: null, wind_speed: null, cloud_coverage: null, pressure: null });
                const live = reactive({ power: 0, yield: 0, price: null });
                const currentPrice = reactive({ total_price: null, net_price: null, hour: null });
                const hasBattery = ref(false);  // True if battery sensor is configured
                const forecast = reactive({ todayTotal: 0, todayTotalCorrected: null, todayRemaining: 0, tomorrowTotal: 0, dayAfterTomorrowTotal: 0, todayHours: [], tomorrowHours: [], dayAfterTomorrowHours: [], maxHourly: 0.5 });
                const todayAccuracy = ref(null);  // Tagesgenauigkeit in %
                const bestHour = reactive({ hour: null, prediction_kwh: null });
                const kpis = reactive({ weekProduction: 0, avgAccuracy: 0, priceMin: 0, priceMax: 0, forecastWeek: 0 });

                // NEW: Energy Flow & Statistics
                const energyFlow = reactive({
                    flows: { solar_power: null, solar_to_house: null, solar_to_battery: null, battery_to_house: null, grid_to_house: null, grid_to_battery: null, house_to_grid: null },
                    battery: { soc: null, power: null },
                    home: { consumption: null },
                    statistics: { solar_yield_daily: null, grid_import_daily: null, grid_import_yearly: null, battery_charge_solar_daily: null, battery_charge_grid_daily: null, price_total: null },
                    panels: []  // Individual PV panels [{id, name, power, max_today}, ...]
                });

                // Production Time & Sun Times
                const productionTime = reactive({ active: false, start_time: null, end_time: null, duration_seconds: 0 });
                const sunTimes = reactive({ sunrise: null, sunset: null });

                // Sun Position (from astronomy_cache.json)
                const sunPosition = reactive({ elevation_deg: null, azimuth_deg: null, direction: null, sunrise: null, sunset: null, daylight_hours: null });

                // Price Stats for Chart Header (Heute & Morgen)
                const priceStats = reactive({ max: '—', maxHour: '—', min: '—', minHour: '—' });
                const priceStatsTomorrow = reactive({ max: '—', maxHour: '—', min: '—', minHour: '—' });

                const stats = reactive({
                    peaks: { today: {}, all_time: {} },
                    production: { today: {}, tomorrow: {} },
                    statistics: { current_week: {}, current_month: {}, last_7_days: {}, last_30_days: {}, last_365_days: {} }
                });

                // Panel Groups (Prognose + IST pro Gruppe)
                const panelGroups = reactive({
                    available: false,
                    groups: {}
                });

                // Panel Group Modal
                const panelGroupModal = reactive({
                    isOpen: false,
                    groupName: '',
                    groupData: null
                });

                // Production Today Modal
                const productionTodayModal = reactive({
                    isOpen: false,
                    hourlyData: []
                });

                // History Stats für erweiterte Charts
                const historyStats = reactive({
                    avgProduction: null,
                    avgForecast: null,
                    avgAccuracy: null,
                    totalProduction: null,
                    allTimePeak: null,
                    monthPeak: null,
                    weeklySavings: null
                });

                // Energy Balance - Stromrechnung & Autarkie (Jahresbilanz)
                const energyBalance = reactive({
                    period: 'year',  // Jetzt immer Jahresbilanz
                    periodStart: null,  // Start des Abrechnungszeitraums
                    periodEnd: null,  // Ende (heute)
                    periodProgress: 0,  // Fortschritt in %
                    daysElapsed: 0,  // Tage seit Start
                    daysTotal: 365,  // Gesamte Tage
                    totalConsumption: null,  // Gesamtverbrauch in kWh (aus Smartmeter)
                    solarProduction: null,  // Gesamte Solarproduktion kWh
                    solarSelfConsumption: null,  // Solar-Eigenverbrauch in kWh
                    batteryContribution: null,  // Akku → Haus in kWh
                    gridImport: null,  // Netzbezug in kWh (das bezahlt man!)
                    gridExport: null,  // Einspeisung in kWh
                    autarkiePercent: null,  // (Solar + Akku) / Gesamtverbrauch * 100
                    solarSelfPercent: null,  // Solar-Anteil am Verbrauch
                    batteryPercent: null,  // Akku-Anteil am Verbrauch
                    gridPercent: null,  // Netz-Anteil am Verbrauch
                    estimatedCost: null,  // Geschätzte Stromkosten in €
                    avgPrice: null,  // Durchschnittlicher Strompreis ct/kWh
                    priceMode: 'dynamic',  // 'fixed' oder 'dynamic'
                    savings: null,  // Ersparnis durch Solar + Akku in €
                    savedKwh: null,  // Gesparte kWh (nicht vom Netz bezogen)
                    projectedYearlyCost: null,  // Hochrechnung auf ganzes Jahr
                    projectedYearlySavings: null,  // Hochgerechnete Ersparnis
                    avgDailyProduction: null,  // Ø Tagesproduktion
                    bestDay: null,  // Bester Tag
                    bestDayKwh: null,  // kWh am besten Tag
                    // Detaillierte Flows aus Riemann-Akkumulation
                    solarToHouse: 0,  // Solar → Haus kWh
                    solarToBattery: 0,  // Solar → Akku kWh
                    batteryToHouse: 0,  // Akku → Haus kWh
                    batteryToGrid: 0,  // Akku → Netz kWh (Einspeisung aus Akku)
                    homeConsumption: 0,  // Hausverbrauch kWh (aus Accumulator)
                    gridToHouse: 0,  // Netz → Haus kWh
                    gridToBattery: 0,  // Netz → Akku kWh
                    houseToGrid: 0,  // Einspeisung kWh
                    // Akkumulator-Status
                    accumulatorSamples: 0,  // Anzahl Messungen
                    accumulatorAvailable: false,  // Ob Daten verfügbar sind
                });

                // Solar Analytics Modal
                const solarModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekTotal: 0,
                        monthTotal: 0,
                        yearTotal: 0,
                        avgAccuracy: 0,
                        peakPower: 0,
                        avgDaily: 0
                    },
                    historicalData: []
                });
                const solarProductionChart = ref(null);
                const solarHeatmapChart = ref(null);
                const solarAccuracyChart = ref(null);
                const solarPanelGroupChart = ref(null);

                // Battery Analytics Modal
                const batteryModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekCharged: 0,
                        weekDischarged: 0,
                        avgSOC: 0,
                        efficiency: 0,
                        cycles: 0,
                        peakPower: 0
                    },
                    historicalData: []
                });
                const batterySOCChart = ref(null);
                const batteryChargeChart = ref(null);
                const batteryEfficiencyChart = ref(null);
                const batteryPowerChart = ref(null);

                // House Analytics Modal
                const houseModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekConsumption: 0,
                        avgDaily: 0,
                        autarky: 0,
                        selfConsumption: 0,
                        solarCoverage: 0,
                        peakPower: 0
                    },
                    historicalData: []
                });
                const houseConsumptionChart = ref(null);
                const houseAutarkyChart = ref(null);
                const houseSourcesChart = ref(null);
                const housePeakChart = ref(null);

                // Grid Analytics Modal
                const gridModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekImport: 0,
                        weekExport: 0,
                        netBalance: 0,
                        avgPrice: 0,
                        costs: 0,
                        revenue: 0
                    },
                    historicalData: []
                });
                const gridFlowChart = ref(null);
                const gridPriceChart = ref(null);
                const gridMoneyChart = ref(null);
                const gridPatternChart = ref(null);

                // Weather Analytics Modal
                const weatherModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        avgTemp: 0,
                        maxTemp: 0,
                        minTemp: 0,
                        totalRain: 0,
                        avgWind: 0,
                        sunHours: 0
                    },
                    historicalData: []
                });
                const weatherTempChart = ref(null);

                // Clothing Recommendation Modal
                const clothingModal = reactive({
                    isOpen: false,
                    title: 'Außenteam-Ausrüstungsanalyse',
                    text: '',
                    recommendation: {
                        unterbekleidung: { name: '', icon: '' },
                        oberbekleidung: { name: '', icon: '' },
                        jacke: { name: '', icon: '' },
                        kopfbedeckung: { name: '', icon: '' },
                        zusaetze: []
                    },
                    weather: {
                        temperature: null,
                        feels_like: null,
                        humidity: null,
                        wind_speed: null,
                        rain_probability: null,
                        uv_index: null
                    },
                    labels: {
                        temperature: 'Temperatur',
                        feels_like: 'Gefühlt',
                        humidity: 'Luftfeuchtigkeit',
                        wind: 'Wind',
                        rain_prob: 'Regenwahrsch.',
                        pants: 'Hose',
                        top: 'Oberteil',
                        jacket: 'Jacke',
                        headwear: 'Kopfbedeckung',
                        accessories: 'Zubehör'
                    }
                });

                // Power Sources Modal
                const powerSourcesModal = reactive({
                    isOpen: false,
                    activeTab: 'today',
                    exporting: false,
                    stats: {
                        solarTotal: 0,
                        solarToHouse: 0,
                        solarToBattery: 0,
                        batteryTotal: 0,
                        gridTotal: 0,
                        consumptionTotal: 0,
                        autarky: 0,
                        selfConsumption: 0
                    },
                    historicalData: [],
                    customStartDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    customEndDate: new Date().toISOString().split('T')[0]
                });
                const powerSourcesPreviewChart = ref(null);
                const powerSourcesMainChart = ref(null);
                const powerSourcesSOCChart = ref(null);
                const powerSourcesPieChart = ref(null);
                const weatherRadiationChart = ref(null);
                const weatherRainChart = ref(null);
                const weatherWindChart = ref(null);
                // IST vs KI Comparison Charts
                const weatherTempComparisonChart = ref(null);
                const weatherRadiationComparisonChart = ref(null);
                const weatherCloudsComparisonChart = ref(null);
                const weatherAccuracyChart = ref(null);

                const productionChart = ref(null);
                const priceChart = ref(null);
                const timelineChart = ref(null);
                const todayProductionChart = ref(null);
                const accuracyChart = ref(null);
                // Neue Chart-Refs
                const trendChart = ref(null);
                // Panel Group Chart Refs (dynamisch)
                const panelGroupChartRefs = reactive({});
                const panelGroupCharts = reactive({});
                const monthlyChart = ref(null);
                let charts = {};

                // Echtzeit-Produktionsdaten für heute (stündlich)
                const todayProduction = reactive({ hours: [], currentPower: 0 });

                const weatherIcon = computed(() => {
                    if (weather.radiation > 400) return '☀️';
                    if (weather.radiation > 150) return '🌤️';
                    if (weather.clouds > 80) return '☁️';
                    if (weather.clouds > 50) return '⛅';
                    return '🌥️';
                });

                const weatherCondition = computed(() => {
                    if (weather.radiation > 400) return 'Sonnig';
                    if (weather.radiation > 150) return 'Heiter';
                    if (weather.clouds > 80) return 'Bewölkt';
                    return 'Wechselhaft';
                });

                const weatherHAIcon = computed(() => {
                    const state = weatherHA.state?.toLowerCase() || '';
                    if (state.includes('sunny') || state.includes('clear')) return '☀️';
                    if (state.includes('partly') || state.includes('cloudy')) return '⛅';
                    if (state.includes('cloud') || state.includes('overcast')) return '☁️';
                    if (state.includes('rain') || state.includes('shower')) return '🌧️';
                    if (state.includes('thunder') || state.includes('storm')) return '⛈️';
                    if (state.includes('snow')) return '❄️';
                    if (state.includes('fog') || state.includes('mist')) return '🌫️';
                    if (state.includes('wind')) return '💨';
                    return '🌤️';
                });

                function getGridPower() {
                    const imp = energyFlow.flows.grid_to_house || 0;
                    const exp = energyFlow.flows.house_to_grid || 0;
                    const net = imp - exp;
                    return Math.abs(net).toFixed(0);
                }

                function getGridLabel() {
                    const imp = energyFlow.flows.grid_to_house || 0;
                    const exp = energyFlow.flows.house_to_grid || 0;
                    if (exp > imp) return 'Einspeisung';
                    if (imp > 0) return 'Bezug';
                    return 'Netz';
                }

                function formatTime(isoString) {
                    if (!isoString) return '';
                    try {
                        const d = new Date(isoString);
                        return d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    } catch { return ''; }
                }

                function formatTimeShort(timeString) {
                    if (!timeString) return '—';
                    // API liefert bereits HH:MM Format, aber zur Sicherheit auch ISO unterstützen
                    if (typeof timeString === 'string') {
                        if (timeString.includes('T')) {
                            try {
                                const d = new Date(timeString);
                                return d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                            } catch { return timeString.slice(0, 5); }
                        }
                        // Already in HH:MM format
                        return timeString.slice(0, 5);
                    }
                    return '—';
                }

                function formatDuration(seconds) {
                    if (!seconds) return '—';
                    const hours = Math.floor(seconds / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${mins}m`;
                }

                // ===== SOLAR ANALYTICS MODAL =====
                function openSolarModal() {
                    console.log('Opening Solar Analytics Modal...');
                    solarModal.isOpen = true;

                    // Step 1: Wait for modal DOM to render
                    setTimeout(() => {
                        console.log('Step 1: Initializing charts...');
                        initSolarCharts();

                        // Step 2: Wait for charts to init, then load data
                        setTimeout(() => {
                            console.log('Step 2: Fetching and rendering data...');
                            updateSolarCharts();
                        }, 200);
                    }, 300);
                }

                function closeSolarModal() {
                    solarModal.isOpen = false;
                    // Dispose charts to prevent memory leaks
                    if (solarProductionChart.value) solarProductionChart.value.dispose();
                    if (solarHeatmapChart.value) solarHeatmapChart.value.dispose();
                    if (solarAccuracyChart.value) solarAccuracyChart.value.dispose();
                    if (solarPanelGroupChart.value) solarPanelGroupChart.value.dispose();
                    solarProductionChart.value = null;
                    solarHeatmapChart.value = null;
                    solarAccuracyChart.value = null;
                    solarPanelGroupChart.value = null;
                }

                async function exportSolarAnalytics() {
                    try {
                        solarModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Solar Analytics');

                        const exportData = {
                            period: solarModal.activeTab,
                            stats: solarModal.stats,
                            data: solarModal.historicalData
                        };

                        const response = await fetch('/api/sfml_stats/export_solar_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });

                        if (!response.ok) {
                            throw new Error(`Export failed: ${response.statusText}`);
                        }

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `solar_analytics_${solarModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);

                        Toast.success('Chart wurde exportiert', 'Solar Analytics');
                    } catch (error) {
                        console.error('Export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        solarModal.exporting = false;
                    }
                }

                // ===== BATTERY ANALYTICS MODAL FUNCTIONS =====
                function openBatteryModal() {
                    console.log('Opening Battery Analytics Modal...');
                    batteryModal.isOpen = true;
                    setTimeout(() => {
                        initBatteryCharts();
                        setTimeout(() => {
                            updateBatteryCharts();
                        }, 200);
                    }, 300);
                }

                function closeBatteryModal() {
                    batteryModal.isOpen = false;
                    if (batterySOCChart.value) batterySOCChart.value.dispose();
                    if (batteryChargeChart.value) batteryChargeChart.value.dispose();
                    if (batteryEfficiencyChart.value) batteryEfficiencyChart.value.dispose();
                    if (batteryPowerChart.value) batteryPowerChart.value.dispose();
                    batterySOCChart.value = null;
                    batteryChargeChart.value = null;
                    batteryEfficiencyChart.value = null;
                    batteryPowerChart.value = null;
                }

                async function exportBatteryAnalytics() {
                    try {
                        batteryModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Batterie Analytics');
                        const exportData = {
                            period: batteryModal.activeTab,
                            stats: batteryModal.stats,
                            data: batteryModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_battery_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `battery_analytics_${batteryModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Batterie Analytics');
                    } catch (error) {
                        console.error('Battery export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        batteryModal.exporting = false;
                    }
                }

                function initBatteryCharts() {
                    setTimeout(() => {
                        const socEl = document.getElementById('battery-soc-chart');
                        const chargeEl = document.getElementById('battery-charge-chart');
                        const efficiencyEl = document.getElementById('battery-efficiency-chart');
                        const powerEl = document.getElementById('battery-power-chart');
                        if (socEl && socEl.offsetWidth > 0) batterySOCChart.value = echarts.init(socEl);
                        if (chargeEl && chargeEl.offsetWidth > 0) batteryChargeChart.value = echarts.init(chargeEl);
                        if (efficiencyEl && efficiencyEl.offsetWidth > 0) batteryEfficiencyChart.value = echarts.init(efficiencyEl);
                        if (powerEl && powerEl.offsetWidth > 0) batteryPowerChart.value = echarts.init(powerEl);
                    }, 150);
                }

                async function updateBatteryCharts() {
                    try {
                        // Fetch real daily stats from API
                        const days = batteryModal.activeTab === 'week' ? 7 : batteryModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];

                        if (result.success && result.daily_stats) {
                            // Convert daily_stats object to array sorted by date
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                // Charged = solar_to_battery + grid charging (from history)
                                const chargedFromSolar = dayData.solar_to_battery_kwh || 0;
                                const chargedFromGrid = dayData.battery_charge_grid_kwh || 0;
                                const chargedKwh = chargedFromSolar + chargedFromGrid;
                                // Discharged = battery_to_house
                                const dischargedKwh = dayData.battery_to_house_kwh || 0;
                                // Efficiency = discharged / charged (if both > 0)
                                const efficiency = chargedKwh > 0 ? (dischargedKwh / chargedKwh) * 100 : 0;

                                history.push({
                                    date: dateStr,
                                    soc: dayData.avg_soc || 0, // Not available yet
                                    charged_kwh: chargedKwh,
                                    discharged_kwh: dischargedKwh,
                                    efficiency: Math.min(100, efficiency),
                                    peak_power_w: dayData.peak_battery_power_w || 0
                                });
                            }
                        }

                        // Fallback if no data
                        if (history.length === 0) {
                            console.warn('No battery stats available, showing empty data');
                        }

                        batteryModal.historicalData = history;

                        // Calculate stats - week is Monday-Sunday of current week
                        const now = new Date();
                        const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, ...
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        // Filter data for current week (Monday-Sunday)
                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);

                        batteryModal.stats.weekCharged = weekData.reduce((sum, d) => sum + d.charged_kwh, 0);
                        batteryModal.stats.weekDischarged = weekData.reduce((sum, d) => sum + d.discharged_kwh, 0);
                        batteryModal.stats.avgSOC = history.length > 0 ? history.reduce((sum, d) => sum + d.soc, 0) / history.length : 0;
                        const totalCharged = history.reduce((sum, d) => sum + d.charged_kwh, 0);
                        const totalDischarged = history.reduce((sum, d) => sum + d.discharged_kwh, 0);
                        batteryModal.stats.efficiency = totalCharged > 0 ? (totalDischarged / totalCharged) * 100 : 0;
                        batteryModal.stats.cycles = batteryModal.stats.weekDischarged / 10; // Assume 10kWh capacity
                        batteryModal.stats.peakPower = history.length > 0 ? Math.max(...history.map(d => d.peak_power_w)) : 0;

                        renderBatteryCharts();
                    } catch (error) {
                        console.error('Error fetching battery data:', error);
                    }
                }

                function renderBatteryCharts() {
                    const tab = batteryModal.activeTab;
                    const data = batteryModal.historicalData || [];

                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // SOC Chart
                    if (batterySOCChart.value) {
                        batterySOCChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'SOC (%)', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'SOC',
                                type: 'line',
                                data: data.map(d => d.soc),
                                smooth: true,
                                itemStyle: { color: '#22c55e' },
                                lineStyle: { width: 2 },
                                areaStyle: { color: 'rgba(34, 197, 94, 0.2)' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }

                    // Charge/Discharge Chart
                    if (batteryChargeChart.value) {
                        batteryChargeChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' } },
                            legend: { data: ['Geladen', 'Entladen'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Geladen', type: 'bar', data: data.map(d => d.charged_kwh), itemStyle: { color: '#22c55e' } },
                                { name: 'Entladen', type: 'bar', data: data.map(d => -d.discharged_kwh), itemStyle: { color: '#fb923c' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Efficiency Chart
                    if (batteryEfficiencyChart.value) {
                        const avgEff = data.reduce((sum, d) => sum + d.efficiency, 0) / data.length;
                        batteryEfficiencyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#3b82f6', textStyle: { color: '#fff' } },
                            legend: { data: ['Wirkungsgrad', 'Durchschnitt'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Wirkungsgrad', type: 'line', data: data.map(d => d.efficiency), smooth: true, itemStyle: { color: '#3b82f6' }, lineStyle: { width: 2 } },
                                { name: 'Durchschnitt', type: 'line', data: Array(data.length).fill(avgEff), lineStyle: { type: 'dashed', color: '#fb923c' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Power Chart - Peak Battery Power per day
                    if (batteryPowerChart.value) {
                        batteryPowerChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'W', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Peak Leistung',
                                type: 'bar',
                                data: data.map(d => d.peak_battery_power_w || 0),
                                itemStyle: { color: '#22c55e' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }
                }

                // ===== HOUSE ANALYTICS MODAL FUNCTIONS =====
                function openHouseModal() {
                    console.log('Opening House Analytics Modal...');
                    houseModal.isOpen = true;
                    setTimeout(() => {
                        initHouseCharts();
                        setTimeout(() => {
                            updateHouseCharts();
                        }, 200);
                    }, 300);
                }

                function closeHouseModal() {
                    houseModal.isOpen = false;
                    if (houseConsumptionChart.value) houseConsumptionChart.value.dispose();
                    if (houseAutarkyChart.value) houseAutarkyChart.value.dispose();
                    if (houseSourcesChart.value) houseSourcesChart.value.dispose();
                    if (housePeakChart.value) housePeakChart.value.dispose();
                    houseConsumptionChart.value = null;
                    houseAutarkyChart.value = null;
                    houseSourcesChart.value = null;
                    housePeakChart.value = null;
                }

                async function exportHouseAnalytics() {
                    try {
                        houseModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Haus Analytics');
                        const exportData = {
                            period: houseModal.activeTab,
                            stats: houseModal.stats,
                            data: houseModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_house_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `house_analytics_${houseModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Haus Analytics');
                    } catch (error) {
                        console.error('House export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        houseModal.exporting = false;
                    }
                }

                function initHouseCharts() {
                    setTimeout(() => {
                        const consumptionEl = document.getElementById('house-consumption-chart');
                        const autarkyEl = document.getElementById('house-autarky-chart');
                        const sourcesEl = document.getElementById('house-sources-chart');
                        const peakEl = document.getElementById('house-peak-chart');
                        if (consumptionEl && consumptionEl.offsetWidth > 0) houseConsumptionChart.value = echarts.init(consumptionEl);
                        if (autarkyEl && autarkyEl.offsetWidth > 0) houseAutarkyChart.value = echarts.init(autarkyEl);
                        if (sourcesEl && sourcesEl.offsetWidth > 0) houseSourcesChart.value = echarts.init(sourcesEl);
                        if (peakEl && peakEl.offsetWidth > 0) housePeakChart.value = echarts.init(peakEl);
                    }, 150);
                }

                async function updateHouseCharts() {
                    try {
                        // Fetch real daily stats from API
                        const days = houseModal.activeTab === 'week' ? 7 : houseModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];

                        if (result.success && result.daily_stats) {
                            // Convert daily_stats object to array sorted by date
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                const solarKwh = (dayData.solar_to_house_kwh || 0) + (dayData.solar_to_battery_kwh || 0);
                                const batteryKwh = dayData.battery_to_house_kwh || 0;
                                const gridKwh = dayData.grid_to_house_kwh || 0;
                                const consumptionKwh = dayData.home_consumption_kwh || (solarKwh + batteryKwh + gridKwh);

                                // Use API values if available, otherwise calculate
                                let autarky = dayData.autarky_percent;
                                if (autarky === undefined || autarky === null) {
                                    // Autarkie = (Verbrauch - Netzbezug) / Verbrauch = 1 - (Netz / Verbrauch)
                                    autarky = consumptionKwh > 0 ? Math.max(0, (1 - gridKwh / consumptionKwh) * 100) : 0;
                                }
                                let selfConsumption = dayData.self_consumption_percent;
                                if (selfConsumption === undefined || selfConsumption === null) {
                                    const totalSolar = (dayData.solar_yield_kwh || solarKwh);
                                    selfConsumption = totalSolar > 0 ? (solarKwh / totalSolar) * 100 : 0;
                                }

                                history.push({
                                    date: dateStr,
                                    consumption_kwh: consumptionKwh,
                                    solar_kwh: solarKwh,
                                    battery_kwh: batteryKwh,
                                    grid_kwh: gridKwh,
                                    autarky: Math.min(100, autarky),
                                    self_consumption: Math.min(100, selfConsumption),
                                    peak_power_w: dayData.peak_consumption_w || dayData.peak_battery_power_w || 0
                                });
                            }
                        }

                        // Fallback if no data
                        if (history.length === 0) {
                            console.warn('No daily stats available, showing empty data');
                        }

                        houseModal.historicalData = history;

                        // Calculate stats - weekConsumption is Monday-Sunday of current week
                        const now = new Date();
                        const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, ...
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        // Filter data for current week (Monday-Sunday)
                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);

                        houseModal.stats.weekConsumption = weekData.reduce((sum, d) => sum + d.consumption_kwh, 0);
                        houseModal.stats.avgDaily = history.length > 0 ? history.reduce((sum, d) => sum + d.consumption_kwh, 0) / history.length : 0;
                        houseModal.stats.autarky = history.length > 0 ? history.reduce((sum, d) => sum + d.autarky, 0) / history.length : 0;
                        houseModal.stats.selfConsumption = history.length > 0 ? history.reduce((sum, d) => sum + d.self_consumption, 0) / history.length : 0;
                        const totalSolar = history.reduce((sum, d) => sum + d.solar_kwh, 0);
                        const totalConsumption = history.reduce((sum, d) => sum + d.consumption_kwh, 0);
                        houseModal.stats.solarCoverage = totalConsumption > 0 ? (totalSolar / totalConsumption) * 100 : 0;
                        houseModal.stats.peakPower = history.length > 0 ? Math.max(...history.map(d => d.peak_power_w)) : 0;

                        renderHouseCharts();
                    } catch (error) {
                        console.error('Error fetching house data:', error);
                    }
                }

                function renderHouseCharts() {
                    const data = houseModal.historicalData || [];
                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // Consumption Chart
                    if (houseConsumptionChart.value) {
                        houseConsumptionChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Verbrauch',
                                type: 'bar',
                                data: data.map(d => d.consumption_kwh),
                                itemStyle: { color: '#00ffff' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }

                    // Autarky Chart
                    if (houseAutarkyChart.value) {
                        houseAutarkyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            legend: { data: ['Autarkie', 'Eigenverbrauch'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Autarkie', type: 'line', data: data.map(d => d.autarky), smooth: true, itemStyle: { color: '#22c55e' }, lineStyle: { width: 2 } },
                                { name: 'Eigenverbrauch', type: 'line', data: data.map(d => d.self_consumption), smooth: true, itemStyle: { color: '#fbbf24' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Sources Chart (Pie)
                    if (houseSourcesChart.value) {
                        const totalSolar = data.reduce((sum, d) => sum + d.solar_kwh, 0);
                        const totalBattery = data.reduce((sum, d) => sum + d.battery_kwh, 0);
                        const totalGrid = data.reduce((sum, d) => sum + d.grid_kwh, 0);

                        houseSourcesChart.value.setOption({
                            tooltip: { trigger: 'item', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            legend: { top: '5%', left: 'center', textStyle: { color: '#fff' } },
                            series: [{
                                name: 'Energiequellen',
                                type: 'pie',
                                radius: ['40%', '70%'],
                                avoidLabelOverlap: false,
                                itemStyle: { borderRadius: 10, borderColor: '#1a1a2e', borderWidth: 2 },
                                label: { show: true, color: '#fff' },
                                data: [
                                    { value: totalSolar, name: 'Solar', itemStyle: { color: '#fbbf24' } },
                                    { value: totalBattery, name: 'Batterie', itemStyle: { color: '#22c55e' } },
                                    { value: totalGrid, name: 'Netz', itemStyle: { color: '#8b5cf6' } }
                                ]
                            }]
                        });
                    }

                    // Peak Chart
                    if (housePeakChart.value) {
                        housePeakChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'W', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Peak Verbrauch',
                                type: 'bar',
                                data: data.map(d => d.peak_power_w),
                                itemStyle: { color: '#00ffff' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }
                }

                // ===== GRID ANALYTICS MODAL FUNCTIONS =====
                function openGridModal() {
                    console.log('Opening Grid Analytics Modal...');
                    gridModal.isOpen = true;
                    setTimeout(() => {
                        initGridCharts();
                        setTimeout(() => {
                            updateGridCharts();
                        }, 200);
                    }, 300);
                }

                function closeGridModal() {
                    gridModal.isOpen = false;
                    if (gridFlowChart.value) gridFlowChart.value.dispose();
                    if (gridPriceChart.value) gridPriceChart.value.dispose();
                    if (gridMoneyChart.value) gridMoneyChart.value.dispose();
                    if (gridPatternChart.value) gridPatternChart.value.dispose();
                    gridFlowChart.value = null;
                    gridPriceChart.value = null;
                    gridMoneyChart.value = null;
                    gridPatternChart.value = null;
                }

                async function exportGridAnalytics() {
                    try {
                        gridModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Netz Analytics');
                        const exportData = {
                            period: gridModal.activeTab,
                            stats: gridModal.stats,
                            data: gridModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_grid_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `grid_analytics_${gridModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Netz Analytics');
                    } catch (error) {
                        console.error('Grid export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        gridModal.exporting = false;
                    }
                }

                function initGridCharts() {
                    setTimeout(() => {
                        const flowEl = document.getElementById('grid-flow-chart');
                        const priceEl = document.getElementById('grid-price-chart');
                        const moneyEl = document.getElementById('grid-money-chart');
                        const patternEl = document.getElementById('grid-pattern-chart');
                        if (flowEl && flowEl.offsetWidth > 0) gridFlowChart.value = echarts.init(flowEl);
                        if (priceEl && priceEl.offsetWidth > 0) gridPriceChart.value = echarts.init(priceEl);
                        if (moneyEl && moneyEl.offsetWidth > 0) gridMoneyChart.value = echarts.init(moneyEl);
                        if (patternEl && patternEl.offsetWidth > 0) gridPatternChart.value = echarts.init(patternEl);
                    }, 150);
                }

                async function updateGridCharts() {
                    try {
                        // Fetch real daily stats from API
                        const days = gridModal.activeTab === 'week' ? 7 : gridModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];

                        if (result.success && result.daily_stats) {
                            // Convert daily_stats object to array sorted by date
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                const importKwh = dayData.grid_to_house_kwh || 0;
                                const exportKwh = Math.abs(dayData.grid_export_kwh || 0);
                                const avgPrice = dayData.price_ct_kwh || dayData.avg_price_ct || 35; // Default 35 ct/kWh

                                history.push({
                                    date: dateStr,
                                    import_kwh: importKwh,
                                    export_kwh: exportKwh,
                                    avg_price_ct: avgPrice,
                                    costs_eur: (importKwh * avgPrice) / 100,
                                    revenue_eur: (exportKwh * 8) / 100 // Assume 8ct feed-in tariff
                                });
                            }
                        }

                        // Fallback if no data
                        if (history.length === 0) {
                            console.warn('No grid stats available, showing empty data');
                        }

                        gridModal.historicalData = history;

                        // Calculate stats - week is Monday-Sunday of current week
                        const now = new Date();
                        const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, ...
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        // Filter data for current week (Monday-Sunday)
                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);
                        const monthData = history.slice(-30);

                        gridModal.stats.weekImport = weekData.reduce((sum, d) => sum + d.import_kwh, 0);
                        gridModal.stats.weekExport = weekData.reduce((sum, d) => sum + d.export_kwh, 0);
                        gridModal.stats.netBalance = gridModal.stats.weekImport - gridModal.stats.weekExport;
                        gridModal.stats.avgPrice = history.length > 0 ? history.reduce((sum, d) => sum + d.avg_price_ct, 0) / history.length : 0;
                        gridModal.stats.costs = weekData.reduce((sum, d) => sum + d.costs_eur, 0);
                        gridModal.stats.revenue = weekData.reduce((sum, d) => sum + d.revenue_eur, 0);

                        renderGridCharts();
                    } catch (error) {
                        console.error('Error fetching grid data:', error);
                    }
                }

                function renderGridCharts() {
                    const data = gridModal.historicalData || [];
                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // Grid Flow Chart
                    if (gridFlowChart.value) {
                        gridFlowChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Bezug', 'Einspeisung'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Bezug', type: 'bar', data: data.map(d => d.import_kwh), itemStyle: { color: '#ef4444' }, stack: 'total' },
                                { name: 'Einspeisung', type: 'bar', data: data.map(d => -d.export_kwh), itemStyle: { color: '#22c55e' }, stack: 'total' }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Price Chart
                    if (gridPriceChart.value) {
                        const avgPrice = data.reduce((sum, d) => sum + d.avg_price_ct, 0) / data.length;
                        gridPriceChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Strompreis', 'Durchschnitt'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'ct/kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Strompreis', type: 'line', data: data.map(d => d.avg_price_ct), smooth: true, itemStyle: { color: '#8b5cf6' }, lineStyle: { width: 2 }, areaStyle: { color: 'rgba(139, 92, 246, 0.2)' } },
                                { name: 'Durchschnitt', type: 'line', data: Array(data.length).fill(avgPrice), lineStyle: { type: 'dashed', color: '#fbbf24' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Money Chart
                    if (gridMoneyChart.value) {
                        gridMoneyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Kosten', 'Erlöse'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '€', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Kosten', type: 'bar', data: data.map(d => d.costs_eur), itemStyle: { color: '#ef4444' } },
                                { name: 'Erlöse', type: 'bar', data: data.map(d => d.revenue_eur), itemStyle: { color: '#22c55e' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Pattern Chart
                    if (gridPatternChart.value) {
                        const netFlow = data.map(d => d.import_kwh - d.export_kwh);
                        gridPatternChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Netto-Energiefluss',
                                type: 'bar',
                                data: netFlow,
                                itemStyle: {
                                    color: (params) => params.value > 0 ? '#ef4444' : '#22c55e'
                                }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }
                }

                // ===== POWER SOURCES MODAL FUNCTIONS =====
                function openPowerSourcesModal() {
                    console.log('Opening Power Sources Modal...');
                    powerSourcesModal.isOpen = true;
                    setTimeout(() => {
                        initPowerSourcesCharts();
                        setTimeout(() => {
                            loadPowerSourcesData('today');
                        }, 200);
                    }, 300);
                }

                function closePowerSourcesModal() {
                    powerSourcesModal.isOpen = false;
                    if (powerSourcesMainChart.value) powerSourcesMainChart.value.dispose();
                    if (powerSourcesSOCChart.value) powerSourcesSOCChart.value.dispose();
                    if (powerSourcesPieChart.value) powerSourcesPieChart.value.dispose();
                    powerSourcesMainChart.value = null;
                    powerSourcesSOCChart.value = null;
                    powerSourcesPieChart.value = null;
                }

                function changePowerSourcesTab(tab) {
                    powerSourcesModal.activeTab = tab;
                    if (tab === 'custom') {
                        // Load custom range data automatically when switching to custom tab
                        loadPowerSourcesCustomRange();
                    } else {
                        loadPowerSourcesData(tab);
                    }
                }

                async function loadPowerSourcesData(period) {
                    try {
                        // Map period to hours
                        const hoursMap = { 'today': 24, 'yesterday': 48, 'week': 168 };
                        const hours = hoursMap[period] || 24;

                        const response = await fetch(`/api/sfml_stats/power_sources_history?hours=${hours}`);
                        const result = await response.json();

                        if (result.success && result.data) {
                            // Filter data based on period
                            let filteredData = result.data;
                            if (period === 'today') {
                                const todayStart = new Date();
                                todayStart.setHours(0, 0, 0, 0);
                                filteredData = result.data.filter(d => new Date(d.timestamp) >= todayStart);
                            } else if (period === 'yesterday') {
                                const yesterday = new Date();
                                yesterday.setDate(yesterday.getDate() - 1);
                                yesterday.setHours(0, 0, 0, 0);
                                const todayStart = new Date();
                                todayStart.setHours(0, 0, 0, 0);
                                filteredData = result.data.filter(d => {
                                    const dt = new Date(d.timestamp);
                                    return dt >= yesterday && dt < todayStart;
                                });
                            }

                            powerSourcesModal.historicalData = filteredData;
                            calculatePowerSourcesStats(filteredData);
                            updatePowerSourcesCharts(filteredData);
                        }
                    } catch (error) {
                        console.error('Error loading power sources data:', error);
                    }
                }

                function calculatePowerSourcesStats(data) {
                    if (!data || data.length === 0) return;

                    // Calculate totals
                    // Data is in Watt (W), we need kWh
                    // Formula: kWh = W * hours / 1000
                    // With 5-minute intervals: kWh = W * (5/60) / 1000 = W / 12000
                    const intervalHours = 5 / 60;  // 0.0833 hours per interval
                    let solarToHouseSum = 0, solarToBatterySum = 0, batterySum = 0, gridSum = 0, consumptionSum = 0;

                    data.forEach(d => {
                        solarToHouseSum += (d.solar_to_house || 0);
                        solarToBatterySum += (d.solar_to_battery || 0);
                        batterySum += (d.battery_to_house || 0);
                        gridSum += (d.grid_to_house || 0);
                        consumptionSum += (d.home_consumption || 0);
                    });

                    // Convert W to kWh: W * intervalHours / 1000
                    powerSourcesModal.stats.solarToHouse = (solarToHouseSum * intervalHours) / 1000;
                    powerSourcesModal.stats.solarToBattery = (solarToBatterySum * intervalHours) / 1000;
                    powerSourcesModal.stats.solarTotal = powerSourcesModal.stats.solarToHouse + powerSourcesModal.stats.solarToBattery;
                    powerSourcesModal.stats.batteryTotal = (batterySum * intervalHours) / 1000;
                    powerSourcesModal.stats.gridTotal = (gridSum * intervalHours) / 1000;
                    powerSourcesModal.stats.consumptionTotal = (consumptionSum * intervalHours) / 1000;

                    // Calculate autarky: (Verbrauch - Netzbezug) / Verbrauch = 1 - (Netz / Verbrauch)
                    const totalConsumption = powerSourcesModal.stats.consumptionTotal;
                    const gridToHouse = powerSourcesModal.stats.gridTotal;

                    if (totalConsumption > 0) {
                        powerSourcesModal.stats.autarky = Math.min(100, Math.max(0, (1 - gridToHouse / totalConsumption) * 100));
                    }

                    // Self-consumption: Eigenverbrauch / Solar gesamt
                    const totalSolar = powerSourcesModal.stats.solarTotal;
                    if (totalSolar > 0) {
                        powerSourcesModal.stats.selfConsumption = Math.min(100, ((powerSourcesModal.stats.solarToHouse + powerSourcesModal.stats.solarToBattery) / totalSolar) * 100);
                    }
                }

                function initPowerSourcesCharts() {
                    setTimeout(() => {
                        const mainEl = document.getElementById('power-sources-main-chart');
                        const socEl = document.getElementById('power-sources-soc-chart');
                        const pieEl = document.getElementById('power-sources-pie-chart');

                        if (mainEl && mainEl.offsetWidth > 0) {
                            powerSourcesMainChart.value = echarts.init(mainEl);
                        }
                        if (socEl && socEl.offsetWidth > 0) {
                            powerSourcesSOCChart.value = echarts.init(socEl);
                        }
                        if (pieEl && pieEl.offsetWidth > 0) {
                            powerSourcesPieChart.value = echarts.init(pieEl);
                        }
                    }, 150);
                }

                function updatePowerSourcesCharts(data) {
                    if (!data || data.length === 0) return;

                    // Extract data arrays
                    // Convert W to kW for display (divide by 1000)
                    const timestamps = data.map(d => {
                        const dt = new Date(d.timestamp);
                        return dt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    });
                    const solarToHouse = data.map(d => (d.solar_to_house || 0) / 1000);
                    const solarToBattery = data.map(d => (d.solar_to_battery || 0) / 1000);
                    const battery = data.map(d => (d.battery_to_house || 0) / 1000);
                    const grid = data.map(d => (d.grid_to_house || 0) / 1000);
                    const consumption = data.map(d => (d.home_consumption || 0) / 1000);
                    const soc = data.map(d => d.battery_soc);

                    // Main stacked area chart with DataZoom slider
                    if (powerSourcesMainChart.value) {
                        console.log('Setting Power Sources chart with dataZoom, data points:', timestamps.length);
                        powerSourcesMainChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                axisPointer: { type: 'cross' },
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#00ffff',
                                textStyle: { color: '#fff' },
                                formatter: function(params) {
                                    let html = `<div style="font-weight:bold;">${params[0].axisValue}</div>`;
                                    params.forEach(p => {
                                        html += `<div style="color:${p.color}">${p.seriesName}: ${p.value?.toFixed(2) || 0} kW</div>`;
                                    });
                                    return html;
                                }
                            },
                            legend: {
                                data: ['Solar → Haus', 'Solar → Batterie', 'Batterie → Haus', 'Netz → Haus', 'Verbrauch'],
                                textStyle: { color: '#94a3b8' },
                                top: 10
                            },
                            grid: { left: '3%', right: '4%', top: 60, bottom: '18%', containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8', rotate: 45 }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'kW',
                                min: 0,
                                max: function(value) {
                                    // Dynamische Skalierung: Max + 10% Puffer, mindestens 0.5 kW
                                    return Math.max(0.5, Math.ceil(value.max * 1.1 * 10) / 10);
                                },
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8' },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            dataZoom: [
                                { type: 'slider', start: 0, end: 100, textStyle: { color: '#94a3b8' }, height: 30 },
                                { type: 'inside', start: 0, end: 100 }
                            ],
                            series: [
                                {
                                    name: 'Solar → Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: solarToHouse,
                                    itemStyle: { color: '#FFB74D' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Solar → Batterie',
                                    type: 'line',
                                    areaStyle: { opacity: 0.6 },
                                    data: solarToBattery,
                                    itemStyle: { color: '#9ACD32' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Batterie → Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: battery,
                                    itemStyle: { color: '#4DD0E1' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Netz → Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: grid,
                                    itemStyle: { color: '#90CAF9' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Verbrauch',
                                    type: 'line',
                                    data: consumption,
                                    itemStyle: { color: '#ffffff' },
                                    lineStyle: { width: 2, type: 'solid' },
                                    smooth: true,
                                    showSymbol: false
                                }
                            ]
                        });
                    }

                    // SOC chart
                    if (powerSourcesSOCChart.value) {
                        powerSourcesSOCChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#22c55e',
                                textStyle: { color: '#fff' }
                            },
                            grid: { left: 50, right: 20, top: 20, bottom: 60 },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: {
                                    color: '#94a3b8',
                                    rotate: 45,
                                    fontSize: 9,
                                    interval: Math.floor(timestamps.length / 8)
                                }
                            },
                            yAxis: {
                                type: 'value',
                                min: 0,
                                max: 100,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            series: [{
                                type: 'line',
                                data: soc,
                                areaStyle: {
                                    color: {
                                        type: 'linear',
                                        x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(34, 197, 94, 0.6)' },
                                            { offset: 1, color: 'rgba(34, 197, 94, 0.1)' }
                                        ]
                                    }
                                },
                                itemStyle: { color: '#22c55e' },
                                lineStyle: { width: 2 },
                                smooth: true,
                                showSymbol: false
                            }]
                        });
                    }

                    // Pie chart
                    if (powerSourcesPieChart.value) {
                        const stats = powerSourcesModal.stats;
                        powerSourcesPieChart.value.setOption({
                            tooltip: {
                                trigger: 'item',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#00ffff',
                                textStyle: { color: '#fff' },
                                formatter: '{b}: {c} kWh ({d}%)'
                            },
                            series: [{
                                type: 'pie',
                                radius: ['40%', '70%'],
                                center: ['50%', '50%'],
                                avoidLabelOverlap: true,
                                itemStyle: {
                                    borderRadius: 5,
                                    borderColor: '#1e1e3e',
                                    borderWidth: 2
                                },
                                label: {
                                    show: true,
                                    color: '#94a3b8',
                                    formatter: '{b}\n{d}%'
                                },
                                data: [
                                    { value: stats.solarToHouse.toFixed(2), name: 'Solar → Haus', itemStyle: { color: '#FFB74D' } },
                                    { value: stats.batteryTotal.toFixed(2), name: 'Batterie → Haus', itemStyle: { color: '#4DD0E1' } },
                                    { value: stats.gridTotal.toFixed(2), name: 'Netz → Haus', itemStyle: { color: '#90CAF9' } }
                                ]
                            }]
                        });
                    }
                }

                async function exportPowerSourcesAnalytics() {
                    try {
                        powerSourcesModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Energiequellen');

                        const exportData = {
                            period: powerSourcesModal.activeTab,
                            stats: powerSourcesModal.stats,
                            data: powerSourcesModal.historicalData
                        };

                        const response = await fetch('/api/sfml_stats/export_power_sources', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });

                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `power_sources_${powerSourcesModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Energiequellen');
                    } catch (error) {
                        console.error('Power sources export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        powerSourcesModal.exporting = false;
                    }
                }

                async function loadPowerSourcesCustomRange() {
                    try {
                        const startDate = new Date(powerSourcesModal.customStartDate);
                        const endDate = new Date(powerSourcesModal.customEndDate);
                        endDate.setHours(23, 59, 59, 999);  // End of day

                        // Calculate hours between dates
                        const hoursDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60));
                        const hours = Math.min(168, Math.max(1, hoursDiff));  // Max 7 days

                        console.log(`Loading custom range: ${powerSourcesModal.customStartDate} to ${powerSourcesModal.customEndDate} (${hours} hours)`);

                        const response = await fetch(`/api/sfml_stats/power_sources_history?hours=${hours}`);
                        const result = await response.json();

                        if (result.success && result.data) {
                            // Filter data to match the selected date range
                            const filteredData = result.data.filter(d => {
                                const dt = new Date(d.timestamp);
                                return dt >= startDate && dt <= endDate;
                            });

                            powerSourcesModal.historicalData = filteredData;
                            calculatePowerSourcesStats(filteredData);
                            updatePowerSourcesCharts(filteredData);
                        }
                    } catch (error) {
                        console.error('Error loading custom range:', error);
                    }
                }

                // ===== WEATHER ANALYTICS MODAL FUNCTIONS =====
                function openWeatherModal() {
                    console.log('Opening Weather Analytics Modal...');
                    weatherModal.isOpen = true;
                    setTimeout(() => {
                        initWeatherCharts();
                        setTimeout(() => {
                            updateWeatherCharts();
                        }, 200);
                    }, 300);
                }

                // ===== CLOTHING RECOMMENDATION MODAL =====
                async function openClothingModal() {
                    console.log('Opening Clothing Recommendation Modal...');
                    clothingModal.isOpen = true;
                    await fetchClothingRecommendation();
                }

                function closeClothingModal() {
                    clothingModal.isOpen = false;
                }

                async function fetchClothingRecommendation() {
                    try {
                        const response = await fetch('/api/sfml_stats/clothing_recommendation');
                        const data = await response.json();

                        if (data.success && data.recommendation) {
                            const rec = data.recommendation;

                            // Update recommendation
                            clothingModal.recommendation.unterbekleidung = rec.unterbekleidung || { name: '', icon: '' };
                            clothingModal.recommendation.oberbekleidung = rec.oberbekleidung || { name: '', icon: '' };
                            clothingModal.recommendation.jacke = rec.jacke || { name: '', icon: '' };
                            clothingModal.recommendation.kopfbedeckung = rec.kopfbedeckung || { name: '', icon: '' };
                            clothingModal.recommendation.zusaetze = rec.zusaetze || [];

                            // Update text based on language preference
                            const lang = navigator.language?.startsWith('en') ? 'en' : 'de';
                            clothingModal.text = lang === 'en' ? rec.text_en : rec.text_de;
                            clothingModal.title = lang === 'en' ? 'Starfleet Uniform Advisory' : 'Außenteam-Ausrüstungsanalyse';

                            // Update labels based on language
                            if (lang === 'en') {
                                clothingModal.labels = {
                                    temperature: 'Temperature',
                                    feels_like: 'Feels like',
                                    humidity: 'Humidity',
                                    wind: 'Wind',
                                    rain_prob: 'Rain prob.',
                                    pants: 'Pants',
                                    top: 'Top',
                                    jacket: 'Jacket',
                                    headwear: 'Headwear',
                                    accessories: 'Accessories'
                                };
                            } else {
                                clothingModal.labels = {
                                    temperature: 'Temperatur',
                                    feels_like: 'Gefühlt',
                                    humidity: 'Luftfeuchtigkeit',
                                    wind: 'Wind',
                                    rain_prob: 'Regenwahrsch.',
                                    pants: 'Hose',
                                    top: 'Oberteil',
                                    jacket: 'Jacke',
                                    headwear: 'Kopfbedeckung',
                                    accessories: 'Zubehör'
                                };
                            }

                            // Update weather data
                            if (data.weather) {
                                clothingModal.weather.temperature = data.weather.temperature;
                                clothingModal.weather.feels_like = data.weather.feels_like;
                                clothingModal.weather.humidity = data.weather.humidity;
                                clothingModal.weather.wind_speed = data.weather.wind_speed;
                                clothingModal.weather.rain_probability = data.weather.rain_probability;
                                clothingModal.weather.uv_index = data.weather.uv_index;
                            }

                            console.log('Clothing recommendation loaded:', rec);
                        } else {
                            console.error('Failed to load clothing recommendation:', data.error);
                            clothingModal.text = 'Kleidungsempfehlung konnte nicht geladen werden.';
                        }
                    } catch (error) {
                        console.error('Error fetching clothing recommendation:', error);
                        clothingModal.text = 'Fehler beim Laden der Kleidungsempfehlung.';
                    }
                }

                // ===== PANEL GROUP MODAL =====
                function openPanelGroupModal(groupName) {
                    const groupData = panelGroups.groups[groupName];
                    if (!groupData) return;

                    panelGroupModal.groupName = groupName;
                    panelGroupModal.groupData = groupData;
                    panelGroupModal.isOpen = true;
                }

                function closePanelGroupModal() {
                    panelGroupModal.isOpen = false;
                    panelGroupModal.groupName = '';
                    panelGroupModal.groupData = null;
                }

                function getPanelGroupDeviation() {
                    if (!panelGroupModal.groupData) return 0;
                    const actual = panelGroupModal.groupData.actual_total_kwh || 0;
                    const prediction = panelGroupModal.groupData.prediction_total_kwh || 0;
                    if (prediction === 0) return 0;
                    return ((actual - prediction) / prediction) * 100;
                }

                function getPanelGroupHourlyData() {
                    if (!panelGroupModal.groupData || !panelGroupModal.groupData.hourly) return [];

                    return panelGroupModal.groupData.hourly
                        .sort((a, b) => a.hour - b.hour)
                        .map(h => {
                            const actual = h.actual_kwh || 0;
                            const prediction = h.prediction_kwh || 0;
                            let deviation = 0;
                            if (prediction > 0) {
                                deviation = ((actual - prediction) / prediction) * 100;
                            }
                            return {
                                hour: h.hour,
                                actual: actual,
                                prediction: prediction,
                                deviation: deviation
                            };
                        });
                }

                // ===== PRODUCTION TODAY MODAL =====
                function openProductionTodayModal() {
                    productionTodayModal.isOpen = true;
                }

                function closeProductionTodayModal() {
                    productionTodayModal.isOpen = false;
                }

                function getProductionTodayDeviation() {
                    const actual = energyFlow.statistics.solar_yield_daily || 0;
                    const prediction = forecast.todayTotal || 0;
                    if (prediction === 0) return 0;
                    return ((actual - prediction) / prediction) * 100;
                }

                function getProductionTodayHourlyData() {
                    // Hole die stündlichen Daten aus forecast.todayHours
                    if (!forecast.todayHours || forecast.todayHours.length === 0) return [];

                    const now = new Date();
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');

                    // Hole IST-Werte aus den hourly forecasts (die haben actual_kwh)
                    return forecast.todayHours
                        .sort((a, b) => a.hour - b.hour)
                        .map(h => {
                            const actual = h.actual || 0;
                            const prediction = h.kwh || 0;
                            let deviation = 0;
                            let accuracy = 0;
                            if (prediction > 0) {
                                deviation = ((actual - prediction) / prediction) * 100;
                                const absDeviation = Math.abs(deviation);
                                accuracy = Math.max(0, 100 - absDeviation);
                            }
                            return {
                                hour: h.hour,
                                actual: actual,
                                prediction: prediction,
                                deviation: deviation,
                                accuracy: accuracy
                            };
                        });
                }

                function closeWeatherModal() {
                    weatherModal.isOpen = false;
                    if (weatherTempChart.value) weatherTempChart.value.dispose();
                    if (weatherRadiationChart.value) weatherRadiationChart.value.dispose();
                    if (weatherRainChart.value) weatherRainChart.value.dispose();
                    if (weatherWindChart.value) weatherWindChart.value.dispose();
                    if (weatherTempComparisonChart.value) weatherTempComparisonChart.value.dispose();
                    if (weatherRadiationComparisonChart.value) weatherRadiationComparisonChart.value.dispose();
                    if (weatherCloudsComparisonChart.value) weatherCloudsComparisonChart.value.dispose();
                    if (weatherAccuracyChart.value) weatherAccuracyChart.value.dispose();
                    weatherTempChart.value = null;
                    weatherRadiationChart.value = null;
                    weatherRainChart.value = null;
                    weatherWindChart.value = null;
                    weatherTempComparisonChart.value = null;
                    weatherRadiationComparisonChart.value = null;
                    weatherCloudsComparisonChart.value = null;
                    weatherAccuracyChart.value = null;
                }

                async function exportWeatherAnalytics() {
                    try {
                        weatherModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Wetter Analytics');

                        // For comparison tab, default to week for export
                        const period = weatherModal.activeTab === 'comparison' ? 'week' : weatherModal.activeTab;

                        const exportData = {
                            period: period,
                            stats: weatherModal.stats,
                            data: weatherModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_weather_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `weather_analytics_${period}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Wetter Analytics');
                    } catch (error) {
                        console.error('Weather export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        weatherModal.exporting = false;
                    }
                }

                function initWeatherCharts() {
                    setTimeout(() => {
                        // Historical charts
                        const tempEl = document.getElementById('weather-temp-chart');
                        const radiationEl = document.getElementById('weather-radiation-chart');
                        const rainEl = document.getElementById('weather-rain-chart');
                        const windEl = document.getElementById('weather-wind-chart');
                        if (tempEl && tempEl.offsetWidth > 0) weatherTempChart.value = echarts.init(tempEl);
                        if (radiationEl && radiationEl.offsetWidth > 0) weatherRadiationChart.value = echarts.init(radiationEl);
                        if (rainEl && rainEl.offsetWidth > 0) weatherRainChart.value = echarts.init(rainEl);
                        if (windEl && windEl.offsetWidth > 0) weatherWindChart.value = echarts.init(windEl);

                        // IST vs KI Comparison charts - only initialize if comparison tab is active
                        if (weatherModal.activeTab === 'comparison') {
                            initWeatherComparisonCharts();
                        }
                    }, 150);
                }

                function initWeatherComparisonCharts() {
                    setTimeout(() => {
                        const tempCompEl = document.getElementById('weather-temp-comparison-chart');
                        const radCompEl = document.getElementById('weather-radiation-comparison-chart');
                        const cloudsCompEl = document.getElementById('weather-clouds-comparison-chart');
                        const accuracyEl = document.getElementById('weather-accuracy-chart');

                        if (tempCompEl && tempCompEl.offsetWidth > 0 && !weatherTempComparisonChart.value) {
                            weatherTempComparisonChart.value = echarts.init(tempCompEl);
                        }
                        if (radCompEl && radCompEl.offsetWidth > 0 && !weatherRadiationComparisonChart.value) {
                            weatherRadiationComparisonChart.value = echarts.init(radCompEl);
                        }
                        if (cloudsCompEl && cloudsCompEl.offsetWidth > 0 && !weatherCloudsComparisonChart.value) {
                            weatherCloudsComparisonChart.value = echarts.init(cloudsCompEl);
                        }
                        if (accuracyEl && accuracyEl.offsetWidth > 0 && !weatherAccuracyChart.value) {
                            weatherAccuracyChart.value = echarts.init(accuracyEl);
                        }
                    }, 150);
                }

                async function updateWeatherCharts() {
                    try {
                        const response = await fetch('/api/sfml_stats/weather_history');
                        const result = await response.json();

                        if (!result.success || !result.data || result.data.length === 0) {
                            // Fallback: Generate mock data if API not ready or no data
                            console.log('No weather data available, generating mock data');
                            generateMockWeatherData();
                            return;
                        }

                        weatherModal.historicalData = result.data;
                        weatherModal.stats = result.stats || {};
                        renderWeatherCharts();
                    } catch (error) {
                        console.error('Error fetching weather data:', error);
                        generateMockWeatherData();
                    }
                }

                function generateMockWeatherData() {
                    // For comparison tab, generate week data
                    const activeTab = weatherModal.activeTab === 'comparison' ? 'week' : weatherModal.activeTab;
                    const days = activeTab === 'week' ? 7 : activeTab === 'month' ? 30 : 365;
                    const history = [];
                    const now = new Date();

                    for (let i = days - 1; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const temp = 15 + Math.sin(i / 30) * 10 + Math.random() * 5; // Seasonal variation
                        history.push({
                            date: date.toISOString().slice(0, 10),
                            temp_avg: temp,
                            temp_max: temp + 5 + Math.random() * 3,
                            temp_min: temp - 5 - Math.random() * 3,
                            radiation: Math.max(0, 300 + Math.sin(i / 10) * 200 + Math.random() * 100),
                            rain: Math.random() < 0.3 ? Math.random() * 15 : 0, // 30% chance of rain
                            humidity: 50 + Math.random() * 40,
                            wind: 2 + Math.random() * 8,
                            solar_kwh: 8 + Math.random() * 12 // For correlation
                        });
                    }

                    weatherModal.historicalData = history;

                    // Calculate stats
                    const weekData = history.slice(-7);
                    const monthData = history.slice(-30);
                    weatherModal.stats.avgTemp = weekData.reduce((sum, d) => sum + d.temp_avg, 0) / weekData.length;
                    weatherModal.stats.maxTemp = Math.max(...history.map(d => d.temp_max));
                    weatherModal.stats.minTemp = Math.min(...history.map(d => d.temp_min));
                    weatherModal.stats.totalRain = monthData.reduce((sum, d) => sum + d.rain, 0);
                    weatherModal.stats.avgWind = history.reduce((sum, d) => sum + d.wind, 0) / history.length;
                    weatherModal.stats.sunHours = monthData.reduce((sum, d) => sum + (d.radiation > 200 ? 8 : 4), 0);

                    renderWeatherCharts();
                }

                async function renderWeatherCharts() {
                    // Check if we're on the comparison tab
                    if (weatherModal.activeTab === 'comparison') {
                        await renderWeatherComparisonCharts();
                        return;
                    }

                    const allData = weatherModal.historicalData || [];
                    if (!allData.length) return;

                    // Filter data based on active tab
                    const daysToShow = weatherModal.activeTab === 'week' ? 7 :
                                       weatherModal.activeTab === 'month' ? 30 : 365;
                    const data = allData.slice(-daysToShow);

                    const dates = data.map(d => d.date.slice(5));

                    // Temperature Chart
                    if (weatherTempChart.value) {
                        weatherTempChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Durchschnitt', 'Maximum', 'Minimum'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '°C', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Durchschnitt', type: 'line', data: data.map(d => d.temp_avg), smooth: true, itemStyle: { color: '#f59e0b' }, lineStyle: { width: 2 } },
                                { name: 'Maximum', type: 'line', data: data.map(d => d.temp_max), smooth: true, itemStyle: { color: '#ef4444' }, lineStyle: { width: 1, type: 'dashed' } },
                                { name: 'Minimum', type: 'line', data: data.map(d => d.temp_min), smooth: true, itemStyle: { color: '#3b82f6' }, lineStyle: { width: 1, type: 'dashed' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Radiation & Solar Correlation Chart
                    if (weatherRadiationChart.value) {
                        weatherRadiationChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Einstrahlung (W/m²)', 'Solar (kWh)'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: [
                                { type: 'value', name: 'W/m²', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                                { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { show: false } }
                            ],
                            series: [
                                { name: 'Einstrahlung (W/m²)', type: 'bar', data: data.map(d => d.radiation), itemStyle: { color: '#fbbf24' } },
                                { name: 'Solar (kWh)', type: 'line', yAxisIndex: 1, data: data.map(d => d.solar_kwh), smooth: true, itemStyle: { color: '#22c55e' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 60, top: 60, bottom: 50 }
                        });
                    }

                    // Rain & Humidity Chart
                    if (weatherRainChart.value) {
                        weatherRainChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Niederschlag (mm)', 'Luftfeuchtigkeit (%)'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: [
                                { type: 'value', name: 'mm', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                                { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { show: false } }
                            ],
                            series: [
                                { name: 'Niederschlag (mm)', type: 'bar', data: data.map(d => d.rain), itemStyle: { color: '#3b82f6' } },
                                { name: 'Luftfeuchtigkeit (%)', type: 'line', yAxisIndex: 1, data: data.map(d => d.humidity), smooth: true, itemStyle: { color: '#06b6d4' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 60, top: 60, bottom: 50 }
                        });
                    }

                    // Wind Chart
                    if (weatherWindChart.value) {
                        weatherWindChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'm/s', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Wind Geschwindigkeit',
                                type: 'line',
                                data: data.map(d => d.wind),
                                smooth: true,
                                itemStyle: { color: '#a855f7' },
                                lineStyle: { width: 2 },
                                areaStyle: { color: 'rgba(168, 85, 247, 0.2)' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }
                }

                async function renderWeatherComparisonCharts() {
                    // Load real IST vs KI comparison data from API
                    let comparisonData = [];
                    let comparisonStats = {};

                    try {
                        const response = await fetch('/api/sfml_stats/weather_comparison?days=7');
                        const result = await response.json();

                        if (result.success && result.data && result.data.length > 0) {
                            comparisonData = result.data;
                            comparisonStats = result.stats || {};
                            console.log('Weather comparison data loaded:', comparisonData.length, 'days');
                        } else {
                            console.warn('No weather comparison data available:', result.error || 'empty data');
                            return; // Don't render charts with no data
                        }
                    } catch (error) {
                        console.error('Error fetching weather comparison data:', error);
                        return; // Don't render charts on error
                    }

                    // Extract data arrays from comparison data
                    const dates = comparisonData.map(d => d.date.slice(5)); // MM-DD format
                    const tempIST = comparisonData.map(d => d.temp_ist);
                    const tempKI = comparisonData.map(d => d.temp_ki);
                    const radiationIST = comparisonData.map(d => d.radiation_ist);
                    const radiationKI = comparisonData.map(d => d.radiation_ki);
                    const cloudsIST = comparisonData.map(d => d.clouds_ist);
                    const cloudsKI = comparisonData.map(d => d.clouds_ki);

                    // Calculate per-day accuracy
                    const accuracy = comparisonData.map(d => {
                        if (d.temp_ki === 0 && d.radiation_ki === 0) return 0;
                        const tempError = Math.abs(d.temp_ist - d.temp_ki);
                        const radError = d.radiation_ki > 0 ? Math.abs(d.radiation_ist - d.radiation_ki) / 5 : 0;
                        const tempAcc = Math.max(0, 100 - tempError * 10);
                        const radAcc = Math.max(0, 100 - radError);
                        return (tempAcc + radAcc) / 2;
                    });

                    // Temperature IST vs KI Chart
                    if (weatherTempComparisonChart.value) {
                        weatherTempComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Temperatur', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Temperatur (°C)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } }
                            },
                            series: [
                                {
                                    name: 'IST Temperatur',
                                    type: 'line',
                                    data: tempIST,
                                    smooth: true,
                                    itemStyle: { color: '#22c55e' },
                                    lineStyle: { width: 3 },
                                    symbol: 'circle',
                                    symbolSize: 8
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'line',
                                    data: tempKI,
                                    smooth: true,
                                    itemStyle: { color: '#8b5cf6' },
                                    lineStyle: { width: 3, type: 'dashed' },
                                    symbol: 'diamond',
                                    symbolSize: 8
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // Radiation IST vs KI Chart
                    if (weatherRadiationComparisonChart.value) {
                        weatherRadiationComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Strahlung', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Strahlung (W/m²)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } }
                            },
                            series: [
                                {
                                    name: 'IST Strahlung',
                                    type: 'bar',
                                    data: radiationIST,
                                    itemStyle: { color: '#fbbf24' },
                                    barWidth: '40%'
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'bar',
                                    data: radiationKI,
                                    itemStyle: { color: '#8b5cf6', opacity: 0.7 },
                                    barWidth: '40%'
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // Clouds IST vs KI Chart
                    if (weatherCloudsComparisonChart.value) {
                        weatherCloudsComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Wolken', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Wolkendecke (%)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } },
                                min: 0,
                                max: 100
                            },
                            series: [
                                {
                                    name: 'IST Wolken',
                                    type: 'line',
                                    data: cloudsIST,
                                    smooth: true,
                                    itemStyle: { color: '#3b82f6' },
                                    lineStyle: { width: 3 },
                                    areaStyle: { color: 'rgba(59, 130, 246, 0.2)' },
                                    symbol: 'circle',
                                    symbolSize: 8
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'line',
                                    data: cloudsKI,
                                    smooth: true,
                                    itemStyle: { color: '#8b5cf6' },
                                    lineStyle: { width: 3, type: 'dashed' },
                                    areaStyle: { color: 'rgba(139, 92, 246, 0.1)' },
                                    symbol: 'diamond',
                                    symbolSize: 8
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // KI Accuracy Analysis Chart
                    if (weatherAccuracyChart.value) {
                        weatherAccuracyChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' },
                                formatter: (params) => {
                                    const value = params[0].value;
                                    const color = value > 85 ? '#22c55e' : value > 70 ? '#f59e0b' : '#ef4444';
                                    return `${params[0].name}<br/><span style="color: ${color};">●</span> Genauigkeit: ${value.toFixed(1)}%`;
                                }
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'KI Genauigkeit (%)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } },
                                min: 0,
                                max: 100
                            },
                            series: [{
                                name: 'KI Genauigkeit',
                                type: 'bar',
                                data: accuracy,
                                itemStyle: {
                                    color: (params) => {
                                        const value = params.value;
                                        if (value > 85) return '#22c55e'; // Grün
                                        if (value > 70) return '#f59e0b'; // Orange
                                        return '#ef4444'; // Rot
                                    }
                                },
                                barWidth: '60%',
                                label: {
                                    show: true,
                                    position: 'top',
                                    formatter: '{c}%',
                                    color: '#fff',
                                    fontSize: 11
                                }
                            }],
                            grid: { left: 70, right: 30, top: 40, bottom: 70 },
                            visualMap: {
                                show: false,
                                min: 0,
                                max: 100,
                                dimension: 0
                            }
                        });
                    }
                }

                function initSolarCharts() {
                    // Wait a bit longer for Vue to render the modal DOM
                    setTimeout(() => {
                        const productionEl = solarProductionChart.value?.$el || document.getElementById('solar-production-chart');
                        const heatmapEl = solarHeatmapChart.value?.$el || document.getElementById('solar-heatmap-chart');
                        const accuracyEl = solarAccuracyChart.value?.$el || document.getElementById('solar-accuracy-chart');
                        const panelGroupEl = solarPanelGroupChart.value?.$el || document.getElementById('solar-panel-group-chart');

                        console.log('Init charts - Elements found:', {
                            production: !!productionEl,
                            heatmap: !!heatmapEl,
                            accuracy: !!accuracyEl,
                            panelGroup: !!panelGroupEl
                        });

                        if (productionEl && productionEl.offsetWidth > 0) {
                            solarProductionChart.value = echarts.init(productionEl);
                            console.log('Production chart initialized');
                        }
                        if (heatmapEl && heatmapEl.offsetWidth > 0) {
                            solarHeatmapChart.value = echarts.init(heatmapEl);
                            console.log('Heatmap chart initialized');
                        }
                        if (accuracyEl && accuracyEl.offsetWidth > 0) {
                            solarAccuracyChart.value = echarts.init(accuracyEl);
                            console.log('Accuracy chart initialized');
                        }
                        if (panelGroupEl && panelGroupEl.offsetWidth > 0 && panelGroups.available) {
                            solarPanelGroupChart.value = echarts.init(panelGroupEl);
                            console.log('Panel group chart initialized');
                        }
                    }, 150);
                }

                async function updateSolarCharts() {
                    try {
                        // Fetch historical solar data from statistics API (has more details)
                        const response = await fetch('/api/sfml_stats/statistics');
                        const result = await response.json();

                        // Check if we have data
                        if (!result.success || !result.history) {
                            console.warn('No solar data available', result);
                            return;
                        }

                        // Transform API data to expected format
                        const history = result.history.map(d => {
                            // Extract hour from peak_at (format: "HH:MM:SS")
                            let peak_hour = 12;
                            if (d.peak_at) {
                                const hourMatch = d.peak_at.match(/^(\d+):/);
                                if (hourMatch) peak_hour = parseInt(hourMatch[1]);
                            }

                            return {
                                date: d.date,
                                actual_kwh: d.actual_kwh || 0,
                                predicted_kwh: d.predicted_kwh || 0,
                                accuracy: d.accuracy || 0,
                                peak_power_w: d.peak_power_w || 0,
                                peak_hour: peak_hour
                            };
                        });

                        console.log('Solar data loaded:', history.length, 'days', history.slice(0, 3));
                        solarModal.historicalData = history;
                        calculateSolarStats(history);
                        renderSolarCharts();
                    } catch (error) {
                        console.error('Error fetching solar analytics data:', error);
                    }
                }

                function calculateSolarStats(history) {
                    const now = new Date();
                    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    const yearStart = new Date(now.getFullYear(), 0, 1);

                    const weekData = history.filter(d => new Date(d.date) >= weekAgo);
                    const monthData = history.filter(d => new Date(d.date) >= monthAgo);
                    const yearData = history.filter(d => new Date(d.date) >= yearStart);

                    solarModal.stats.weekTotal = weekData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);
                    solarModal.stats.monthTotal = monthData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);
                    solarModal.stats.yearTotal = yearData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);

                    const accuracyData = history.filter(d => d.accuracy > 0);
                    solarModal.stats.avgAccuracy = accuracyData.length > 0
                        ? Math.min(100, accuracyData.reduce((sum, d) => sum + Math.min(100, d.accuracy), 0) / accuracyData.length)
                        : 0;

                    solarModal.stats.peakPower = Math.max(...history.map(d => d.peak_power_w || 0));
                    solarModal.stats.avgDaily = history.length > 0
                        ? history.reduce((sum, d) => sum + (d.actual_kwh || 0), 0) / history.length
                        : 0;
                }

                function renderSolarCharts() {
                    const tab = solarModal.activeTab;
                    let data = [];

                    if (tab === 'week') {
                        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= weekAgo);
                    } else if (tab === 'month') {
                        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= monthAgo);
                    } else {
                        const yearStart = new Date(new Date().getFullYear(), 0, 1);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= yearStart);
                    }

                    data.sort((a, b) => new Date(a.date) - new Date(b.date));

                    renderProductionChart(data);
                    renderHeatmapChart(data);
                    renderAccuracyChart(data);
                    if (panelGroups.available) renderPanelGroupChart();
                }

                function renderProductionChart(data) {
                    if (!solarProductionChart.value) {
                        console.warn('Production chart not initialized yet!');
                        return;
                    }

                    console.log('Rendering production chart with', data.length, 'days');
                    const dates = data.map(d => d.date.slice(5));
                    const actual = data.map(d => d.actual_kwh || 0);
                    const predicted = data.map(d => d.predicted_kwh || 0);

                    console.log('Chart data:', { dates, actual, predicted });

                    solarProductionChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: {
                            data: ['Tatsächlich', 'Prognose'],
                            textStyle: { color: '#94a3b8' },
                            top: 0
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tatsächlich',
                                type: 'bar',
                                data: actual,
                                itemStyle: {
                                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                        { offset: 0, color: '#ffdd00' },
                                        { offset: 1, color: '#ff8c00' }
                                    ]),
                                    borderRadius: [4, 4, 0, 0]
                                }
                            },
                            {
                                name: 'Prognose',
                                type: 'line',
                                data: predicted,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2 },
                                itemStyle: { color: '#8b5cf6' }
                            }
                        ]
                    });
                }

                function renderHeatmapChart(data) {
                    if (!solarHeatmapChart.value) return;

                    // Group data by hour to create heatmap
                    const hourlyData = [];
                    for (let hour = 6; hour <= 20; hour++) {
                        const hourData = data.map((d, idx) => {
                            // Use peak_hour if available, otherwise estimate from data
                            const peakHour = d.peak_hour || 12;
                            const power = d.peak_power_w || 0;
                            // Simulate hourly distribution (bell curve around peak hour)
                            const hourFactor = Math.max(0, 1 - Math.abs(hour - peakHour) / 7);
                            return [idx, hour - 6, Math.round(power * hourFactor)];
                        });
                        hourlyData.push(...hourData);
                    }

                    const dates = data.map(d => d.date.slice(5));
                    const hours = Array.from({ length: 15 }, (_, i) => `${i + 6}:00`);

                    solarHeatmapChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            position: 'top',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                return `${dates[params.value[0]]}<br/>${hours[params.value[1]]}: ${params.value[2]} W`;
                            }
                        },
                        grid: { left: '10%', right: '4%', bottom: '10%', top: '5%' },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) },
                            splitArea: { show: true }
                        },
                        yAxis: {
                            type: 'category',
                            data: hours,
                            axisLabel: { color: '#94a3b8' },
                            splitArea: { show: true }
                        },
                        visualMap: {
                            min: 0,
                            max: Math.max(...hourlyData.map(d => d[2])),
                            calculable: true,
                            orient: 'horizontal',
                            left: 'center',
                            bottom: '0%',
                            inRange: {
                                color: ['#1a1a3a', '#ff8c00', '#ffdd00']
                            },
                            textStyle: { color: '#94a3b8' }
                        },
                        series: [{
                            type: 'heatmap',
                            data: hourlyData,
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(255, 221, 0, 0.5)'
                                }
                            }
                        }]
                    });
                }

                function renderAccuracyChart(data) {
                    if (!solarAccuracyChart.value) return;

                    const dates = data.map(d => d.date.slice(5));
                    const accuracy = data.map(d => d.accuracy || 0);

                    solarAccuracyChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ff8833',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => `${params[0].axisValue}: ${params[0].value.toFixed(1)}%`
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '10%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } },
                            min: 0,
                            max: 100
                        },
                        series: [{
                            type: 'line',
                            data: accuracy,
                            smooth: true,
                            lineStyle: { color: '#00ff88', width: 3 },
                            itemStyle: { color: '#00ff88' },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                    { offset: 1, color: 'rgba(0, 255, 136, 0)' }
                                ])
                            },
                            markLine: {
                                data: [{ type: 'average', name: 'Durchschnitt' }],
                                lineStyle: { color: '#8b5cf6', type: 'dashed' },
                                label: { color: '#8b5cf6' }
                            }
                        }]
                    });
                }

                function renderPanelGroupChart() {
                    if (!solarPanelGroupChart.value || !panelGroups.available) return;

                    const groups = Object.values(panelGroups.groups);
                    const names = groups.map(g => g.name);
                    const production = groups.map(g => g.actual_total_kwh || 0);
                    const prediction = groups.map(g => g.prediction_total_kwh || 0);

                    solarPanelGroupChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: {
                            data: ['Produktion', 'Prognose'],
                            textStyle: { color: '#94a3b8' },
                            top: 0
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: names,
                            axisLabel: { color: '#94a3b8' }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'bar',
                                data: production,
                                itemStyle: { color: '#00ff88', borderRadius: [4, 4, 0, 0] }
                            },
                            {
                                name: 'Prognose',
                                type: 'bar',
                                data: prediction,
                                itemStyle: { color: '#8b5cf6', borderRadius: [4, 4, 0, 0] }
                            }
                        ]
                    });
                }

                // Watch for tab changes to update charts
                watch(() => solarModal.activeTab, () => {
                    if (solarModal.isOpen) {
                        renderSolarCharts();
                    }
                });

                watch(() => batteryModal.activeTab, () => {
                    if (batteryModal.isOpen) {
                        updateBatteryCharts();
                    }
                });

                watch(() => houseModal.activeTab, () => {
                    if (houseModal.isOpen) {
                        updateHouseCharts();
                    }
                });

                watch(() => gridModal.activeTab, () => {
                    if (gridModal.isOpen) {
                        updateGridCharts();
                    }
                });

                watch(() => weatherModal.activeTab, () => {
                    if (weatherModal.isOpen) {
                        // If switching to comparison tab, initialize comparison charts first
                        if (weatherModal.activeTab === 'comparison') {
                            initWeatherComparisonCharts();
                            setTimeout(async () => {
                                await renderWeatherComparisonCharts();
                            }, 200);
                        } else {
                            // For week/month/year tabs, just re-render with existing data (filtered by tab)
                            // Only fetch if no data loaded yet
                            if (weatherModal.historicalData && weatherModal.historicalData.length > 0) {
                                renderWeatherCharts();
                            } else {
                                updateWeatherCharts();
                            }
                        }
                    }
                });

                // Energy Balance - Lädt Jahresbilanz aus Recorder (Riemann-Summe)
                async function fetchBillingData() {
                    try {
                        const res = await fetch('/api/sfml_stats/billing');
                        const data = await res.json();

                        if (!data.success) return;

                        console.log('Billing API Response:', data);

                        // Zeitraum
                        energyBalance.periodStart = data.period?.start;
                        energyBalance.periodEnd = data.period?.end;
                        energyBalance.periodProgress = data.period?.progress_percent || 0;
                        energyBalance.daysElapsed = data.period?.days_elapsed || 0;
                        energyBalance.daysTotal = data.period?.days_total || 365;

                        // ===== HAUSHALT (aus Recorder) =====
                        const household = data.household || {};
                        energyBalance.homeConsumption = household.total_kwh || 0;
                        energyBalance.solarToHouse = household.from_solar_kwh || 0;
                        energyBalance.batteryToHouse = household.from_battery_kwh || 0;
                        energyBalance.gridToHouse = household.from_grid_kwh || 0;

                        // ===== AKKU (aus Recorder) =====
                        const battery = data.battery || {};
                        energyBalance.batteryChargeTotal = battery.total_charge_kwh || 0;
                        energyBalance.solarToBattery = battery.from_solar_kwh || 0;
                        energyBalance.gridToBattery = battery.from_grid_kwh || 0;

                        // ===== SOLAR =====
                        const solar = data.solar || {};
                        energyBalance.solarProduction = solar.total_kwh || 0;

                        // ===== GRID =====
                        const grid = data.grid || {};
                        energyBalance.gridImport = grid.total_import_kwh || 0;
                        energyBalance.gridExport = grid.export_kwh || 0;

                        // ===== FINANZEN =====
                        const finance = data.finance || {};
                        energyBalance.estimatedCost = finance.grid_cost_eur || 0;
                        energyBalance.savings = finance.savings_eur || 0;
                        energyBalance.avgPrice = finance.avg_price_ct || 35;

                        // ===== AUTARKIE =====
                        energyBalance.autarkiePercent = data.autarkie_percent || 0;

                        // ===== RECORDER META =====
                        energyBalance.recorderSamples = data.recorder?.sample_count || 0;
                        energyBalance.recorderAvailable = data.recorder?.data_available || false;

                        // Durchschnitt pro Tag
                        if (energyBalance.daysElapsed > 0) {
                            energyBalance.avgDailyProduction = energyBalance.solarProduction / energyBalance.daysElapsed;
                        }

                        // Berechne Anteile für Breakdown-Chart
                        const totalForBreakdown = energyBalance.homeConsumption;
                        if (totalForBreakdown > 0) {
                            energyBalance.solarSelfPercent = (energyBalance.solarToHouse / totalForBreakdown) * 100;
                            energyBalance.batteryPercent = (energyBalance.batteryToHouse / totalForBreakdown) * 100;
                            energyBalance.gridPercent = (energyBalance.gridToHouse / totalForBreakdown) * 100;
                        }

                        // Hochrechnung auf ganzes Jahr
                        if (energyBalance.daysElapsed > 0 && energyBalance.daysElapsed < energyBalance.daysTotal) {
                            const factor = energyBalance.daysTotal / energyBalance.daysElapsed;
                            energyBalance.projectedYearlySavings = energyBalance.savings * factor;
                        }

                        // Gespartes kWh = Eigenverbrauch (Solar direkt + über Akku)
                        energyBalance.savedKwh = energyBalance.solarToHouse + energyBalance.batteryToHouse;

                        console.log('Energy Balance Updated:', {
                            household: energyBalance.homeConsumption,
                            solar: energyBalance.solarProduction,
                            grid: energyBalance.gridImport,
                            autarkie: energyBalance.autarkiePercent,
                            recorderSamples: energyBalance.recorderSamples
                        });

                    } catch (err) {
                        console.error('Fehler beim Laden der Billing-Daten:', err);
                    }
                }

                // HINWEIS: Die Jahresbilanz kommt ausschließlich aus der Billing API
                // Der sensor_grid_import_yearly zählt ab 01.01., nicht ab Abrechnungsstart!
                // Daher KEIN Fallback auf diesen Sensor - würde falsche Werte zeigen.
                function updateEnergyBalanceFromSensors(energyFlowData, gridImportYearly) {
                    // DEAKTIVIERT: Fallback würde falschen Zeitraum zeigen!
                    // grid_import_yearly = ab 01.01., Abrechnung = ab konfiguriertem Startdatum
                    // Die echten Werte kommen aus hourly_billing_history.json über die Billing API
                    return;
                }

                async function fetchData() {
                    try {
                        const [summaryRes, solarRes, priceRes, energyFlowRes, statsRes] = await Promise.all([
                            fetch('/api/sfml_stats/summary'),
                            fetch('/api/sfml_stats/solar?days=7'),
                            fetch('/api/sfml_stats/prices?days=2'),
                            fetch('/api/sfml_stats/energy_flow'),
                            fetch('/api/sfml_stats/statistics')
                        ]);

                        const summary = await summaryRes.json();
                        const solar = await solarRes.json();
                        const prices = await priceRes.json();
                        const energyFlowData = await energyFlowRes.json();
                        const statsData = await statsRes.json();

                        // Energy Flow
                        if (energyFlowData.success) {
                            // Solar kann NIEMALS negativ sein - korrigiere negative Werte
                            if (energyFlowData.flows) {
                                energyFlowData.flows.solar_to_house = Math.max(0, energyFlowData.flows.solar_to_house || 0);
                                energyFlowData.flows.solar_to_battery = Math.max(0, energyFlowData.flows.solar_to_battery || 0);
                                energyFlowData.flows.solar_power = Math.max(0, energyFlowData.flows.solar_power || 0);
                            }
                            Object.assign(energyFlow.flows, energyFlowData.flows);
                            Object.assign(energyFlow.battery, energyFlowData.battery);
                            Object.assign(energyFlow.home, energyFlowData.home);
                            Object.assign(energyFlow.statistics, energyFlowData.statistics);

                            // Check if battery is configured (has valid SOC value)
                            hasBattery.value = energyFlowData.battery?.soc !== null && energyFlowData.battery?.soc !== undefined;

                            // Panel data
                            if (energyFlowData.panels) {
                                energyFlow.panels = energyFlowData.panels;
                            }

                            // HA Weather Integration
                            if (energyFlowData.weather_ha) {
                                weatherHA.state = energyFlowData.weather_ha.state;
                                weatherHA.temperature = energyFlowData.weather_ha.temperature;
                                weatherHA.humidity = energyFlowData.weather_ha.humidity;
                                weatherHA.wind_speed = energyFlowData.weather_ha.wind_speed;
                                weatherHA.cloud_coverage = energyFlowData.weather_ha.cloud_coverage;
                                weatherHA.pressure = energyFlowData.weather_ha.pressure;
                            }

                            // Sun Position
                            if (energyFlowData.sun_position) {
                                sunPosition.elevation_deg = energyFlowData.sun_position.elevation_deg;
                                sunPosition.azimuth_deg = energyFlowData.sun_position.azimuth_deg;
                                sunPosition.direction = energyFlowData.sun_position.direction;
                                sunPosition.sunrise = energyFlowData.sun_position.sunrise;
                                sunPosition.sunset = energyFlowData.sun_position.sunset;
                                sunPosition.daylight_hours = energyFlowData.sun_position.daylight_hours;
                            }

                            // Current Price (from price_cache.json)
                            if (energyFlowData.current_price) {
                                currentPrice.total_price = energyFlowData.current_price.total_price;
                                currentPrice.net_price = energyFlowData.current_price.net_price;
                                currentPrice.hour = energyFlowData.current_price.hour;
                            }

                            // Energy Balance mit Jahres-Netzbezug ergänzen
                            const gridImportYearly = energyFlowData.statistics?.grid_import_yearly || null;
                            updateEnergyBalanceFromSensors(energyFlowData, gridImportYearly);
                        }

                        // Statistics
                        if (statsData.success) {
                            Object.assign(stats.peaks, statsData.peaks);
                            Object.assign(stats.production, statsData.production);
                            Object.assign(stats.statistics, statsData.statistics);

                            // Beste Stunde (aus daily_forecasts.json)
                            if (statsData.best_hour) {
                                bestHour.hour = statsData.best_hour.hour;
                                bestHour.prediction_kwh = statsData.best_hour.prediction_kwh;
                            }

                            // Panel Groups (Prognose + IST pro Gruppe)
                            if (statsData.panel_groups) {
                                panelGroups.available = statsData.panel_groups.available;
                                panelGroups.groups = statsData.panel_groups.groups || {};
                            }
                        }

                        if (summary.success) {
                            kpis.weekProduction = summary.week?.total_production || 0;
                            kpis.avgAccuracy = summary.week?.avg_accuracy || 0;
                            kpis.priceMin = summary.kpis?.price_min || 0;
                            kpis.priceMax = summary.kpis?.price_max || 0;
                            live.price = summary.kpis?.price_current || 0;

                            // Production Time & Sun Times
                            if (summary.production_time) {
                                Object.assign(productionTime, summary.production_time);
                            }
                            if (summary.sun_times) {
                                Object.assign(sunTimes, summary.sun_times);
                            }
                        }

                        if (solar.success && solar.data) {
                            const hourly = solar.data.hourly || [];
                            const now = new Date();
                            // Lokales Datum verwenden (nicht UTC!)
                            const todayStr = now.getFullYear() + '-' +
                                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                                String(now.getDate()).padStart(2, '0');
                            const tomorrow = new Date(now);
                            tomorrow.setDate(tomorrow.getDate() + 1);
                            const tomorrowStr = tomorrow.getFullYear() + '-' +
                                String(tomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                                String(tomorrow.getDate()).padStart(2, '0');
                            const dayAfterTomorrow = new Date(now);
                            dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2);
                            const dayAfterTomorrowStr = dayAfterTomorrow.getFullYear() + '-' +
                                String(dayAfterTomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                                String(dayAfterTomorrow.getDate()).padStart(2, '0');
                            const currentHour = now.getHours();

                            const currentPred = hourly.find(h => h.target_date === todayStr && h.target_hour === currentHour);
                            if (currentPred) {
                                live.power = (currentPred.actual_kwh || currentPred.prediction_kwh || 0) * 1000;
                            }

                            // IST-Wetter: Primär aus hourly_weather_actual (solar.data.weather)
                            const actualWeather = solar.data.weather?.[todayStr]?.[String(currentHour)];
                            if (actualWeather) {
                                weather.temperature = actualWeather.temperature_c;
                                weather.radiation = actualWeather.solar_radiation_wm2;
                                weather.humidity = actualWeather.humidity_percent;
                                weather.wind = actualWeather.wind_speed_ms;
                                // Wolken aus condition ableiten
                                const cond = (actualWeather.condition || '').toLowerCase();
                                if (cond.includes('clear') || cond.includes('sunny')) weather.clouds = 0;
                                else if (cond.includes('partly')) weather.clouds = 30;
                                else if (cond.includes('cloudy')) weather.clouds = 75;
                                else if (cond.includes('overcast')) weather.clouds = 100;
                                else if (cond.includes('rain') || cond.includes('fog')) weather.clouds = 90;
                                else weather.clouds = 50; // Default
                            } else if (currentPred) {
                                // Fallback: weather_forecast aus predictions
                                const wf = currentPred.weather_forecast || {};
                                weather.temperature = wf.temperature;
                                weather.radiation = wf.solar_radiation_wm2;
                                weather.humidity = wf.humidity;
                                weather.wind = wf.wind;
                                weather.clouds = wf.clouds;
                            }

                            // KI-korrigierte Wetterdaten laden
                            const correctedData = solar.data.weather_corrected?.[todayStr]?.[String(currentHour)];
                            if (correctedData) {
                                weatherCorrected.temperature = correctedData.temperature;
                                weatherCorrected.radiation = correctedData.solar_radiation_wm2;
                                weatherCorrected.humidity = correctedData.humidity;
                                weatherCorrected.wind = correctedData.wind;
                                weatherCorrected.clouds = correctedData.clouds;
                            }

                            const todayPreds = hourly.filter(h => h.target_date === todayStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.todayHours = todayPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0, actual: h.actual_kwh || 0 }));
                            forecast.todayTotal = todayPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Korrigierte Tagesprognose aus daily_forecasts (prediction_kwh_display)
                            const correctedForecast = solar.data.forecasts?.today?.prediction_kwh_display;
                            forecast.todayTotalCorrected = (correctedForecast && correctedForecast !== forecast.todayTotal) ? correctedForecast : null;

                            live.yield = todayPreds.filter(h => h.actual_kwh != null).reduce((s, h) => s + (h.actual_kwh || 0), 0);
                            forecast.todayRemaining = todayPreds.filter(h => h.target_hour > currentHour).reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Tagesgenauigkeit berechnen (nur Stunden mit tatsächlichen Werten)
                            const hoursWithActual = todayPreds.filter(h => h.actual_kwh != null && h.prediction_kwh > 0);
                            if (hoursWithActual.length > 0) {
                                const totalActual = hoursWithActual.reduce((s, h) => s + (h.actual_kwh || 0), 0);
                                const totalPredicted = hoursWithActual.reduce((s, h) => s + (h.prediction_kwh || 0), 0);
                                // Genauigkeit = 100 - |Abweichung in %|
                                if (totalPredicted > 0) {
                                    const deviation = Math.abs((totalActual - totalPredicted) / totalPredicted) * 100;
                                    todayAccuracy.value = Math.max(0, 100 - deviation);
                                }
                            }

                            const tomorrowPreds = hourly.filter(h => h.target_date === tomorrowStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.tomorrowHours = tomorrowPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0 }));
                            forecast.tomorrowTotal = tomorrowPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Fallback: Wenn keine stündlichen Daten für morgen, nutze multi_day_hourly
                            if (forecast.tomorrowHours.length === 0 && solar.data.multi_day_hourly?.[tomorrowStr]) {
                                const multiDayTomorrow = solar.data.multi_day_hourly[tomorrowStr];
                                const tomorrowHourly = (multiDayTomorrow.hourly || []).filter(h => h.hour >= 6 && h.hour <= 20);
                                forecast.tomorrowHours = tomorrowHourly.map(h => ({ hour: h.hour, kwh: h.prediction_kwh || 0 }));
                                forecast.tomorrowTotal = multiDayTomorrow.total_kwh || tomorrowHourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);
                            } else if (forecast.tomorrowHours.length === 0 && solar.data.forecasts?.tomorrow) {
                                forecast.tomorrowTotal = solar.data.forecasts.tomorrow.prediction_kwh || 0;
                            }

                            // Übermorgen-Daten laden
                            const dayAfterTomorrowPreds = hourly.filter(h => h.target_date === dayAfterTomorrowStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.dayAfterTomorrowHours = dayAfterTomorrowPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0 }));
                            forecast.dayAfterTomorrowTotal = dayAfterTomorrowPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Fallback: Wenn keine stündlichen Daten für übermorgen, nutze multi_day_hourly
                            if (forecast.dayAfterTomorrowHours.length === 0 && solar.data.multi_day_hourly?.[dayAfterTomorrowStr]) {
                                const multiDayAfter = solar.data.multi_day_hourly[dayAfterTomorrowStr];
                                const afterHourly = (multiDayAfter.hourly || []).filter(h => h.hour >= 6 && h.hour <= 20);
                                forecast.dayAfterTomorrowHours = afterHourly.map(h => ({ hour: h.hour, kwh: h.prediction_kwh || 0 }));
                                forecast.dayAfterTomorrowTotal = multiDayAfter.total_kwh || afterHourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);
                            } else if (forecast.dayAfterTomorrowHours.length === 0 && solar.data.forecasts?.day_after_tomorrow) {
                                forecast.dayAfterTomorrowTotal = solar.data.forecasts.day_after_tomorrow.prediction_kwh || 0;
                            }

                            forecast.maxHourly = Math.max(0.1, ...forecast.todayHours.map(h => h.kwh), ...forecast.tomorrowHours.map(h => h.kwh), ...forecast.dayAfterTomorrowHours.map(h => h.kwh));
                            kpis.forecastWeek = hourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            updateProductionChart(solar.data.daily || []);
                            updateAccuracyChart(solar.data.daily || []);
                            updateTimelineChart(hourly);

                            // Neuer Tages-Chart mit aktueller Solarleistung
                            const currentSolarPower = energyFlow.flows.solar_power || 0;
                            updateTodayProductionChart(hourly, currentSolarPower);

                            // Panel-Gruppen Charts aktualisieren (nextTick warten bis DOM gerendert)
                            Vue.nextTick(() => {
                                updatePanelGroupCharts();
                            });

                            // Erweiterte Charts mit History-Daten
                            if (solar.data.history) {
                                updateExtendedCharts(solar.data.history, solar.data.astronomy || {}, solar.data.statistics);
                            }
                        }

                        if (prices.success && prices.data?.prices) {
                            updatePriceChart(prices.data.prices, prices.data.statistics);
                        }

                        lastUpdate.value = new Date().toLocaleTimeString('de-DE');
                    } catch (e) { console.error('Fetch error:', e); }
                }

                function initCharts() {
                    if (productionChart.value) charts.production = echarts.init(productionChart.value);
                    if (priceChart.value) charts.price = echarts.init(priceChart.value);
                    if (timelineChart.value) charts.timeline = echarts.init(timelineChart.value);
                    if (todayProductionChart.value) charts.todayProduction = echarts.init(todayProductionChart.value);
                    if (accuracyChart.value) charts.accuracy = echarts.init(accuracyChart.value);
                    // Neue Charts
                    if (trendChart.value) charts.trend = echarts.init(trendChart.value);
                    if (monthlyChart.value) charts.monthly = echarts.init(monthlyChart.value);
                    // Power Sources Preview Chart
                    const powerSourcesEl = document.querySelector('.power-sources-chart-container');
                    if (powerSourcesEl && powerSourcesEl.offsetWidth > 0) {
                        charts.powerSourcesPreview = echarts.init(powerSourcesEl);
                    }
                }

                function updateProductionChart(daily) {
                    if (!charts.production) return;
                    // Chronologisch sortieren (ältester Tag links, neuester rechts)
                    const sorted = [...daily].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const days = sorted.map(d => ['So','Mo','Di','Mi','Do','Fr','Sa'][new Date(d.date).getDay()]);
                    // Genauigkeit pro Tag berechnen
                    const accuracyData = sorted.map(d => d.overall?.accuracy_percent || 0);
                    charts.production.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const idx = params[0].dataIndex;
                                const acc = accuracyData[idx];
                                const dateStr = sorted[idx]?.date || '';
                                let result = `<b>${params[0].axisValue}</b> (${dateStr.slice(5)})<br/>`;
                                params.forEach(p => {
                                    result += `${p.marker} ${p.seriesName}: <b>${p.value?.toFixed(2) || 0} kWh</b><br/>`;
                                });
                                // Genauigkeit mit Farbe
                                const accColor = acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                result += `<span style="color:${accColor}">📊 Genauigkeit: <b>${acc.toFixed(0)}%</b></span>`;
                                return result;
                            }
                        },
                        legend: { data: ['Tatsächlich', 'Vorhersage'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: { type: 'category', data: days, axisLabel: { color: '#94a3b8' } },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            max: function(value) {
                                // Dynamische Skalierung: Max + 15% Puffer, mindestens 1 kWh
                                return Math.max(1, Math.ceil(value.max * 1.15 * 10) / 10);
                            },
                            axisLabel: { color: '#94a3b8' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tatsächlich',
                                type: 'bar',
                                data: sorted.map(d => d.overall?.actual_total_kwh || 0),
                                itemStyle: { color: '#00ff88', borderRadius: [4,4,0,0] },
                                label: {
                                    show: true,
                                    position: 'top',
                                    formatter: (params) => {
                                        const acc = accuracyData[params.dataIndex];
                                        return acc > 0 ? `${acc.toFixed(0)}%` : '';
                                    },
                                    color: params => {
                                        const acc = accuracyData[params.dataIndex];
                                        return acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                    },
                                    fontSize: 10,
                                    fontWeight: 'bold'
                                }
                            },
                            {
                                name: 'Vorhersage',
                                type: 'bar',
                                data: sorted.map(d => d.overall?.predicted_total_kwh || 0),
                                itemStyle: { color: '#3b82f6', borderRadius: [4,4,0,0] }
                            }
                        ]
                    });
                }

                function updateAccuracyChart(daily) {
                    if (!charts.accuracy) return;

                    // Heutiges Datum (ohne Uhrzeit) für Vergleich
                    const today = new Date().toISOString().slice(0, 10);

                    // Chronologisch sortieren und heutigen Tag ausschließen (noch keine vollständigen IST-Werte)
                    const sorted = [...daily]
                        .filter(d => d.date < today)
                        .sort((a, b) => new Date(a.date) - new Date(b.date));

                    if (sorted.length === 0) return;

                    // Wochentage als Labels
                    const days = sorted.map(d => {
                        // T12:00 verhindert Zeitzonenprobleme bei Datumsstrings
                        const dateObj = new Date(d.date + 'T12:00:00');
                        return ['So','Mo','Di','Mi','Do','Fr','Sa'][dateObj.getDay()];
                    });

                    // Abweichung berechnen: (Tatsächlich - Prognose) / Prognose * 100
                    const deviationData = sorted.map(d => {
                        const actual = d.overall?.actual_total_kwh || 0;
                        const predicted = d.overall?.predicted_total_kwh || 0;
                        if (predicted > 0) {
                            return parseFloat(((actual - predicted) / predicted * 100).toFixed(1));
                        }
                        return 0;
                    });

                    charts.accuracy.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const idx = params[0].dataIndex;
                                const d = sorted[idx];
                                const actual = d.overall?.actual_total_kwh || 0;
                                const predicted = d.overall?.predicted_total_kwh || 0;
                                const dev = deviationData[idx];
                                const devColor = dev >= 0 ? '#00ff88' : '#ef4444';
                                const devSign = dev >= 0 ? '+' : '';
                                return `<b>${d.date}</b><br/>
                                    Tatsächlich: <b>${actual.toFixed(2)} kWh</b><br/>
                                    Prognose: <b>${predicted.toFixed(2)} kWh</b><br/>
                                    <span style="color:${devColor}">Abweichung: <b>${devSign}${dev}%</b></span>`;
                            }
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '10%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: days,
                            axisLabel: { color: '#94a3b8' },
                            axisLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Abweichung',
                                type: 'line',
                                data: deviationData,
                                smooth: true,
                                symbol: 'circle',
                                symbolSize: 8,
                                lineStyle: {
                                    color: '#00ffff',
                                    width: 3
                                },
                                itemStyle: {
                                    color: params => params.value >= 0 ? '#00ff88' : '#ef4444',
                                    borderColor: '#0a0a1a',
                                    borderWidth: 2
                                },
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.3)' },
                                            { offset: 0.5, color: 'rgba(0, 255, 255, 0.05)' },
                                            { offset: 1, color: 'rgba(239, 68, 68, 0.3)' }
                                        ]
                                    }
                                },
                                // 0-Linie (Treffer)
                                markLine: {
                                    silent: true,
                                    symbol: 'none',
                                    lineStyle: { color: '#ffdd00', width: 2, type: 'dashed' },
                                    data: [{ yAxis: 0, label: { show: true, formatter: '0% Treffer', color: '#ffdd00', fontSize: 10, position: 'end' } }]
                                },
                                // Min/Max Marker
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 12, itemStyle: { color: '#00ff88' }, label: { formatter: '+{c}%', color: '#00ff88', fontSize: 10 } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 12, itemStyle: { color: '#ef4444' }, label: { formatter: '{c}%', color: '#ef4444', fontSize: 10 } }
                                    ]
                                }
                            }
                        ]
                    });
                }

                function updatePriceChart(prices, stats) {
                    if (!charts.price) return;

                    const now = new Date();
                    // Lokales Datum verwenden (nicht UTC!)
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');

                    // Berechne morgen
                    const tomorrow = new Date(now);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    const tomorrowStr = tomorrow.getFullYear() + '-' +
                        String(tomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                        String(tomorrow.getDate()).padStart(2, '0');

                    // Hilfsfunktion: Datum aus Preis-Objekt extrahieren
                    // Nutzt das 'date' Feld falls vorhanden, sonst parse Timestamp
                    function getPriceDateStr(priceObj) {
                        // Wenn date-Feld vorhanden, direkt nutzen
                        if (priceObj.date) {
                            return priceObj.date;
                        }
                        // Fallback: Timestamp parsen (lokal)
                        const d = new Date(priceObj.timestamp);
                        return d.getFullYear() + '-' +
                            String(d.getMonth() + 1).padStart(2, '0') + '-' +
                            String(d.getDate()).padStart(2, '0');
                    }

                    // Filtere Preise für heute und sortiere nach Stunde
                    const todayPrices = prices
                        .filter(p => getPriceDateStr(p) === todayStr)
                        .sort((a, b) => a.hour - b.hour);

                    // Filtere Preise für morgen und sortiere nach Stunde
                    const tomorrowPrices = prices
                        .filter(p => getPriceDateStr(p) === tomorrowStr)
                        .sort((a, b) => a.hour - b.hour);

                    // Erstelle vollständige 24h Arrays (0-23)
                    const hours = Array.from({length: 24}, (_, i) => i);
                    const todayData = hours.map(h => {
                        const found = todayPrices.find(p => p.hour === h);
                        return found ? found.price_total || 0 : null;
                    });
                    const tomorrowData = hours.map(h => {
                        const found = tomorrowPrices.find(p => p.hour === h);
                        return found ? found.price_total || 0 : null;
                    });

                    // Min/Max für heute berechnen
                    const todayValid = todayData.filter(v => v !== null);
                    if (todayValid.length > 0) {
                        const maxIdx = todayData.indexOf(Math.max(...todayValid));
                        const minIdx = todayData.indexOf(Math.min(...todayValid));
                        priceStats.max = Math.max(...todayValid).toFixed(2);
                        priceStats.maxHour = maxIdx;
                        priceStats.min = Math.min(...todayValid).toFixed(2);
                        priceStats.minHour = minIdx;
                    }

                    // Min/Max für morgen berechnen
                    const tomorrowValid = tomorrowData.filter(v => v !== null);
                    if (tomorrowValid.length > 0) {
                        const maxIdx = tomorrowData.indexOf(Math.max(...tomorrowValid));
                        const minIdx = tomorrowData.indexOf(Math.min(...tomorrowValid));
                        priceStatsTomorrow.max = Math.max(...tomorrowValid).toFixed(2);
                        priceStatsTomorrow.maxHour = maxIdx;
                        priceStatsTomorrow.min = Math.min(...tomorrowValid).toFixed(2);
                        priceStatsTomorrow.minHour = minIdx;
                    } else {
                        priceStatsTomorrow.max = '—';
                        priceStatsTomorrow.min = '—';
                    }

                    charts.price.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                let result = `${params[0].axisValue}<br/>`;
                                params.forEach(p => {
                                    if (p.value !== null) {
                                        result += `${p.seriesName}: <b>${p.value?.toFixed(2)} ct</b><br/>`;
                                    }
                                });
                                return result;
                            }
                        },
                        legend: { data: ['Heute', 'Morgen'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: { type: 'category', data: hours.map(h => h + ':00'), axisLabel: { color: '#94a3b8', interval: 3 } },
                        yAxis: { type: 'value', axisLabel: { color: '#94a3b8', formatter: '{value} ct' }, splitLine: { lineStyle: { color: '#1a1a3a' } } },
                        series: [
                            {
                                name: 'Heute',
                                type: 'line',
                                data: todayData,
                                smooth: true,
                                lineStyle: { color: '#ff0080', width: 3 },
                                areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{offset: 0, color: '#ff008022'}, {offset: 1, color: '#ff008000'}] } },
                                itemStyle: { color: '#ff0080' },
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#ef4444' } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#22c55e' } }
                                    ],
                                    label: { show: false }
                                }
                            },
                            {
                                name: 'Morgen',
                                type: 'line',
                                data: tomorrowData,
                                smooth: true,
                                lineStyle: { color: '#00ffff', width: 3 },
                                areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{offset: 0, color: '#00ffff22'}, {offset: 1, color: '#00ffff00'}] } },
                                itemStyle: { color: '#00ffff' },
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#ef4444' } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#22c55e' } }
                                    ],
                                    label: { show: false }
                                }
                            }
                        ]
                    });
                }

                function updateTimelineChart(hourly) {
                    if (!charts.timeline) return;
                    const sorted = [...hourly].sort((a,b) => new Date(a.target_datetime) - new Date(b.target_datetime)).slice(-72);
                    charts.timeline.setOption({
                        backgroundColor: 'transparent',
                        tooltip: { trigger: 'axis', backgroundColor: '#1e1e3e', borderColor: '#00ffff33', textStyle: { color: '#e2e8f0' } },
                        legend: { data: ['Tatsächlich', 'Vorhersage'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },
                        dataZoom: [{ type: 'slider', start: 60, end: 100, textStyle: { color: '#94a3b8' } }],
                        xAxis: { type: 'category', data: sorted.map(h => (h.target_date?.slice(5)||'') + ' ' + h.target_hour + 'h'), axisLabel: { color: '#94a3b8', rotate: 45 } },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            max: function(value) {
                                // Dynamische Skalierung: Max + 15% Puffer, mindestens 0.5 kWh
                                return Math.max(0.5, Math.ceil(value.max * 1.15 * 10) / 10);
                            },
                            axisLabel: { color: '#94a3b8' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            { name: 'Tatsächlich', type: 'bar', data: sorted.map(h => h.actual_kwh), itemStyle: { color: '#00ff88' } },
                            { name: 'Vorhersage', type: 'line', data: sorted.map(h => h.prediction_kwh), smooth: true, lineStyle: { color: '#3b82f6' }, symbol: 'none' }
                        ]
                    });
                }

                async function updatePowerSourcesPreviewChart() {
                    if (!charts.powerSourcesPreview) return;

                    try {
                        const response = await fetch('/api/sfml_stats/power_sources_history?hours=24');
                        const result = await response.json();

                        if (!result.success || !result.data) return;

                        // Filter auf heute (nur Daten ab Mitternacht)
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const allData = result.data.filter(d => {
                            const dt = new Date(d.timestamp);
                            return dt >= today;
                        });

                        if (allData.length === 0) return;

                        // Filter auf Produktionszeitraum: nur Datenpunkte mit solar_power > 0
                        // oder alle Punkte zwischen erstem und letztem Produktionspunkt
                        let firstProductionIdx = allData.findIndex(d => (d.solar_power || 0) > 10);
                        let lastProductionIdx = allData.length - 1;
                        for (let i = allData.length - 1; i >= 0; i--) {
                            if ((allData[i].solar_power || 0) > 10) {
                                lastProductionIdx = i;
                                break;
                            }
                        }

                        // Wenn keine Produktion, zeige letzte 6 Stunden
                        if (firstProductionIdx === -1) {
                            firstProductionIdx = Math.max(0, allData.length - 72); // 6h bei 5min Intervall
                            lastProductionIdx = allData.length - 1;
                        }

                        // Etwas Puffer hinzufügen (30 min vor und nach)
                        firstProductionIdx = Math.max(0, firstProductionIdx - 6);
                        lastProductionIdx = Math.min(allData.length - 1, lastProductionIdx + 6);

                        const data = allData.slice(firstProductionIdx, lastProductionIdx + 1);

                        const timestamps = data.map(d => {
                            const dt = new Date(d.timestamp);
                            return dt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                        });
                        const solarPower = data.map(d => d.solar_power || 0);

                        charts.powerSourcesPreview.setOption({
                            tooltip: {
                                trigger: 'axis',
                                axisPointer: { type: 'line', lineStyle: { color: '#FFB74D' } },
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#FFB74D',
                                textStyle: { color: '#fff' },
                                formatter: function(params) {
                                    var html = '<div style="font-weight:bold; margin-bottom:5px;">' + params[0].axisValue + '</div>';
                                    params.forEach(function(p) {
                                        html += '<div>' + p.marker + ' ' + p.seriesName + ': <b>' + Math.round(p.value || 0) + ' W</b></div>';
                                    });
                                    return html;
                                }
                            },
                            grid: { left: 50, right: 20, top: 15, bottom: 30 },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLabel: { color: '#64748b', fontSize: 9, interval: Math.floor(timestamps.length / 6) },
                                axisLine: { lineStyle: { color: '#404040' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'W',
                                nameTextStyle: { color: '#94a3b8', fontSize: 10 },
                                axisLabel: { color: '#64748b', fontSize: 9 },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            series: [
                                {
                                    name: 'PV-Leistung',
                                    type: 'line',
                                    data: solarPower,
                                    itemStyle: { color: '#FFB74D' },
                                    lineStyle: { width: 2, color: '#FFB74D' },
                                    areaStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: 0, x2: 0, y2: 1,
                                            colorStops: [
                                                { offset: 0, color: 'rgba(255, 183, 77, 0.6)' },
                                                { offset: 1, color: 'rgba(255, 183, 77, 0.1)' }
                                            ]
                                        }
                                    },
                                    showSymbol: false,
                                    smooth: true
                                }
                            ]
                        });
                    } catch (error) {
                        console.error('Error updating power sources preview:', error);
                    }
                }

                function updateTodayProductionChart(hourly, currentSolarPower) {
                    if (!charts.todayProduction) return;

                    const now = new Date();
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');
                    const currentHour = now.getHours();

                    // Filtere nur heute und sortiere nach Stunde
                    const todayData = hourly
                        .filter(h => h.target_date === todayStr)
                        .sort((a, b) => a.target_hour - b.target_hour);

                    // Produktionszeit dynamisch aus Astrodaten (±2 Stunden)
                    let START_HOUR = 6;  // Fallback
                    let END_HOUR = 20;   // Fallback

                    // Versuche sunrise/sunset aus sunPosition zu lesen (Format: "08:15" oder "2025-12-15T08:15:00+01:00")
                    if (sunPosition.sunrise) {
                        const sunriseStr = sunPosition.sunrise;
                        let sunriseHour;
                        if (sunriseStr.includes('T')) {
                            sunriseHour = parseInt(sunriseStr.split('T')[1].split(':')[0]);
                        } else {
                            sunriseHour = parseInt(sunriseStr.split(':')[0]);
                        }
                        START_HOUR = Math.max(0, sunriseHour - 2);
                    }
                    if (sunPosition.sunset) {
                        const sunsetStr = sunPosition.sunset;
                        let sunsetHour;
                        if (sunsetStr.includes('T')) {
                            sunsetHour = parseInt(sunsetStr.split('T')[1].split(':')[0]);
                        } else {
                            sunsetHour = parseInt(sunsetStr.split(':')[0]);
                        }
                        END_HOUR = Math.min(23, sunsetHour + 2);
                    }

                    const hours = Array.from({length: END_HOUR - START_HOUR + 1}, (_, i) => i + START_HOUR);

                    // Tatsächliche Produktion (kWh pro Stunde) - 0 für fehlende Stunden
                    const actualData = hours.map(h => {
                        const found = todayData.find(d => d.target_hour === h);
                        return found?.actual_kwh ?? 0;
                    });

                    // Vorhersage (kWh pro Stunde) - 0 für fehlende Stunden
                    const forecastData = hours.map(h => {
                        const found = todayData.find(d => d.target_hour === h);
                        return found?.prediction_kwh ?? 0;
                    });

                    // Aktuelle Leistung als Linie (W -> kW für Skalierung)
                    const powerData = hours.map(h => {
                        if (h === currentHour && currentSolarPower > 0) {
                            return (currentSolarPower / 1000).toFixed(2); // W -> kW
                        }
                        return null;
                    });

                    // Genauigkeit pro Stunde berechnen
                    const accuracyData = hours.map(h => {
                        const actual = actualData[h];
                        const pred = forecastData[h];
                        if (actual != null && pred != null && pred > 0) {
                            const deviation = Math.abs((actual - pred) / pred) * 100;
                            return Math.max(0, 100 - deviation);
                        }
                        return null;
                    });

                    charts.todayProduction.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const hourIdx = params[0].dataIndex;
                                let result = `<b>${params[0].axisValue}</b><br/>`;
                                params.forEach(p => {
                                    if (p.value !== null && p.value !== undefined) {
                                        const unit = p.seriesName === 'Aktuell' ? 'kW' : 'kWh';
                                        result += `${p.marker} ${p.seriesName}: <b>${parseFloat(p.value).toFixed(3)} ${unit}</b><br/>`;
                                    }
                                });
                                // Genauigkeit hinzufügen wenn beide Werte vorhanden
                                const acc = accuracyData[hourIdx];
                                if (acc !== null) {
                                    const accColor = acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                    result += `<span style="color:${accColor}">📊 Genauigkeit: <b>${acc.toFixed(0)}%</b></span>`;
                                }
                                return result;
                            }
                        },
                        legend: { data: ['Tatsächlich', 'Vorhersage', 'Aktuell'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: hours.map(h => h + ':00'),
                            axisLabel: { color: '#94a3b8', interval: 2 },
                            axisLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tatsächlich',
                                type: 'line',
                                data: actualData,
                                smooth: true,
                                lineStyle: { color: '#00ff88', width: 3 },
                                itemStyle: { color: '#00ff88' },
                                symbol: 'circle',
                                symbolSize: 6,
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                            { offset: 1, color: 'rgba(0, 255, 136, 0.05)' }
                                        ]
                                    }
                                }
                            },
                            {
                                name: 'Vorhersage',
                                type: 'line',
                                data: forecastData,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                itemStyle: { color: '#8b5cf6' },
                                symbol: 'none',
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(139, 92, 246, 0.2)' },
                                            { offset: 1, color: 'rgba(139, 92, 246, 0)' }
                                        ]
                                    }
                                }
                            },
                            {
                                name: 'Aktuell',
                                type: 'scatter',
                                data: powerData,
                                symbolSize: 15,
                                itemStyle: {
                                    color: '#ffdd00',
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(255, 221, 0, 0.5)'
                                }
                            }
                        ],
                        // Markierung für aktuelle Stunde
                        markLine: {
                            silent: true,
                            data: [{ xAxis: currentHour }],
                            lineStyle: { color: '#ffdd00', width: 2, type: 'solid' },
                            label: { show: false }
                        }
                    });
                }

                // ===== PANEL-GRUPPEN CHART-FUNKTION =====

                function updatePanelGroupCharts() {
                    if (!panelGroups.available || !panelGroups.groups) return;

                    // Produktionszeit dynamisch aus Astrodaten (±2 Stunden)
                    let START_HOUR = 6;  // Fallback
                    let END_HOUR = 20;   // Fallback

                    if (sunPosition.sunrise) {
                        const sunriseStr = sunPosition.sunrise;
                        let sunriseHour;
                        if (sunriseStr.includes('T')) {
                            sunriseHour = parseInt(sunriseStr.split('T')[1].split(':')[0]);
                        } else {
                            sunriseHour = parseInt(sunriseStr.split(':')[0]);
                        }
                        START_HOUR = Math.max(0, sunriseHour - 2);
                    }
                    if (sunPosition.sunset) {
                        const sunsetStr = sunPosition.sunset;
                        let sunsetHour;
                        if (sunsetStr.includes('T')) {
                            sunsetHour = parseInt(sunsetStr.split('T')[1].split(':')[0]);
                        } else {
                            sunsetHour = parseInt(sunsetStr.split(':')[0]);
                        }
                        END_HOUR = Math.min(23, sunsetHour + 2);
                    }

                    const hours = Array.from({length: END_HOUR - START_HOUR + 1}, (_, i) => i + START_HOUR);

                    // Für jede Panel-Gruppe einen Chart erstellen/aktualisieren
                    for (const [groupName, groupData] of Object.entries(panelGroups.groups)) {
                        const chartEl = panelGroupChartRefs[groupName];
                        if (!chartEl) continue;

                        // Chart initialisieren falls nötig
                        if (!panelGroupCharts[groupName]) {
                            panelGroupCharts[groupName] = echarts.init(chartEl);
                        }

                        const chart = panelGroupCharts[groupName];
                        const hourlyData = groupData.hourly || [];

                        // Erstelle Arrays nur für Produktionszeit
                        const actualData = hours.map(h => {
                            const found = hourlyData.find(d => d.hour === h);
                            return found?.actual_kwh ?? 0;
                        });
                        const forecastData = hours.map(h => {
                            const found = hourlyData.find(d => d.hour === h);
                            return found?.prediction_kwh ?? 0;
                        });

                        chart.setOption({
                            backgroundColor: 'transparent',
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: '#1e1e3e',
                                borderColor: '#00ffff33',
                                textStyle: { color: '#e2e8f0' }
                            },
                            legend: { data: ['IST', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                            grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: hours.map(h => h + ':00'),
                                axisLabel: { color: '#94a3b8', interval: 3, fontSize: 10 },
                                axisLine: { lineStyle: { color: '#1a1a3a' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'kWh',
                                nameTextStyle: { color: '#94a3b8' },
                                axisLabel: { color: '#94a3b8', formatter: v => v.toFixed(3) },
                                splitLine: { lineStyle: { color: '#1a1a3a' } }
                            },
                            series: [
                                {
                                    name: 'IST',
                                    type: 'line',
                                    data: actualData,
                                    smooth: true,
                                    lineStyle: { color: '#00ff88', width: 3 },
                                    itemStyle: { color: '#00ff88' },
                                    symbol: 'circle',
                                    symbolSize: 6,
                                    areaStyle: {
                                        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                            { offset: 1, color: 'rgba(0, 255, 136, 0.05)' }
                                        ])
                                    }
                                },
                                {
                                    name: 'Prognose',
                                    type: 'line',
                                    data: forecastData,
                                    smooth: true,
                                    lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                    itemStyle: { color: '#8b5cf6' },
                                    symbol: 'none'
                                }
                            ]
                        });
                    }
                }

                // ===== ERWEITERTE CHART-FUNKTIONEN =====

                function updateExtendedCharts(history, astronomy, statistics) {
                    // Sortiere History chronologisch
                    const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const last30 = sorted.slice(-30);

                    // Stats berechnen
                    if (last30.length > 0) {
                        historyStats.avgProduction = last30.reduce((s, d) => s + (d.actual_kwh || 0), 0) / last30.length;
                        historyStats.avgForecast = last30.reduce((s, d) => s + (d.predicted_kwh || 0), 0) / last30.length;
                        historyStats.avgAccuracy = Math.min(100, last30.filter(d => d.accuracy > 0).reduce((s, d, _, a) => s + Math.min(100, d.accuracy) / a.length, 0));
                        historyStats.totalProduction = sorted.reduce((s, d) => s + (d.actual_kwh || 0), 0);
                        historyStats.monthPeak = Math.max(...last30.map(d => d.peak_power_w || 0));
                        historyStats.allTimePeak = statistics?.all_time_peak?.power_w || historyStats.monthPeak;
                    }

                    updateTrendChart(last30);
                    updateMonthlyChart(sorted);
                }

                // Chart 1: Langzeit-Trend (30 Tage)
                function updateTrendChart(data) {
                    if (!charts.trend) return;
                    const dates = data.map(d => d.date.slice(5)); // MM-DD
                    const actual = data.map(d => d.actual_kwh || 0);
                    const predicted = data.map(d => d.predicted_kwh || 0);

                    charts.trend.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: { data: ['Produktion', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: 2 }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'line',
                                data: actual,
                                smooth: true,
                                lineStyle: { color: '#00ff88', width: 3 },
                                itemStyle: { color: '#00ff88' },
                                areaStyle: {
                                    color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [{ offset: 0, color: 'rgba(0, 255, 136, 0.4)' }, { offset: 1, color: 'rgba(0, 255, 136, 0)' }]
                                    }
                                }
                            },
                            {
                                name: 'Prognose',
                                type: 'line',
                                data: predicted,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                itemStyle: { color: '#8b5cf6' }
                            }
                        ]
                    });
                }

                // Monats-Vergleich Chart
                function updateMonthlyChart(data) {
                    if (!charts.monthly) return;

                    // Gruppiere nach Monat
                    const monthly = {};
                    data.forEach(d => {
                        const month = d.date.slice(0, 7); // YYYY-MM
                        if (!monthly[month]) monthly[month] = { production: 0, forecast: 0, days: 0 };
                        monthly[month].production += d.actual_kwh || 0;
                        monthly[month].forecast += d.predicted_kwh || 0;
                        monthly[month].days++;
                    });

                    const months = Object.keys(monthly).sort();
                    const monthNames = months.map(m => {
                        const [y, mo] = m.split('-');
                        return ['Jan','Feb','Mär','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'][parseInt(mo)-1] + ' ' + y.slice(2);
                    });
                    const production = months.map(m => monthly[m].production.toFixed(1));
                    const forecast = months.map(m => monthly[m].forecast.toFixed(1));

                    charts.monthly.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: { data: ['Produktion', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: monthNames,
                            axisLabel: { color: '#94a3b8' }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'bar',
                                data: production,
                                itemStyle: { color: '#00ff88', borderRadius: [4, 4, 0, 0] }
                            },
                            {
                                name: 'Prognose',
                                type: 'bar',
                                data: forecast,
                                itemStyle: { color: '#3b82f6', borderRadius: [4, 4, 0, 0] }
                            }
                        ]
                    });
                }


                let interval;
                onMounted(() => {
                    initCharts();
                    fetchBillingData();  // Lade Jahresbilanz-Daten
                    fetchData();
                    // Initialize power sources preview chart
                    setTimeout(() => updatePowerSourcesPreviewChart(), 1500);
                    interval = setInterval(fetchData, 30000);
                    window.addEventListener('resize', () => Object.values(charts).forEach(c => c?.resize()));
                });
                onUnmounted(() => {
                    clearInterval(interval);
                    Object.values(charts).forEach(c => c?.dispose());
                });

                return {
                    lastUpdate, isDarkTheme, toggleTheme, hasBattery,
                    weather, weatherCorrected, weatherHA, weatherIcon, weatherCondition, weatherHAIcon, live, forecast, kpis,
                    productionChart, priceChart, timelineChart, todayProductionChart, accuracyChart,
                    trendChart, monthlyChart,
                    energyFlow, stats, getGridPower, getGridLabel, formatTime,
                    productionTime, sunTimes, formatTimeShort, formatDuration,
                    priceStats, priceStatsTomorrow, sunPosition, bestHour, currentPrice,
                    todayAccuracy, historyStats, energyBalance,
                    panelGroups, panelGroupChartRefs,
                    panelGroupModal, openPanelGroupModal, closePanelGroupModal, getPanelGroupDeviation, getPanelGroupHourlyData,
                    productionTodayModal, openProductionTodayModal, closeProductionTodayModal, getProductionTodayDeviation, getProductionTodayHourlyData,
                    solarModal, openSolarModal, closeSolarModal, exportSolarAnalytics,
                    batteryModal, openBatteryModal, closeBatteryModal, exportBatteryAnalytics,
                    houseModal, openHouseModal, closeHouseModal, exportHouseAnalytics,
                    gridModal, openGridModal, closeGridModal, exportGridAnalytics,
                    weatherModal, openWeatherModal, closeWeatherModal, exportWeatherAnalytics,
                    powerSourcesModal, openPowerSourcesModal, closePowerSourcesModal, exportPowerSourcesAnalytics, changePowerSourcesTab, loadPowerSourcesCustomRange,
                    clothingModal, openClothingModal, closeClothingModal
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
